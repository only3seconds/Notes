## 携程

### Java 基础

#### 1. 写出快速排序的Java代码，并简单分析其复杂度。

```java
package xiecheng;

import java.util.Arrays;

/**
 * 快速排序 （选取第一个元素作为基准）
 * 时间复杂度：O(nlogn)
 *
 */

public class QuickSort {
    public static void main(String[] args) {
        int[] array = {0, 9, 8, 4, 5, 6, 2, 3, 4};
        System.out.println("排序前： " + Arrays.toString(array));
        quickSort(array, 0, array.length - 1);
        System.out.println("排序后： " + Arrays.toString(array));
    }

    public static void quickSort(int[] array, int left, int right) {
        int pivot;
        if (left < right) {
            pivot = partition(array, left, right);
            quickSort(array, left, pivot - 1);
            quickSort(array, pivot + 1, right);
        }
    }

    public static int partition(int[] array, int left, int right) {
        int key = array[left];
        while (left < right) {
            while (left < right && array[right] >= key) {
                right--;
            }
            array[left] = array[right];
            while (left < right && array[left] <= key) {
                left++;
            }
            array[right] = array[left];
        }
        array[left] = key;
        return left
                ;

    }
}
```

#### 2. 你用过JDK那些版本，为什么要使用这个版本

jdk1.7 新特性：

- switch 中可以使用字符串
- 对集合类的语言支持，存取元素变得方便

```java

// 原本需要这样： 
         List<String> list = new ArrayList<String>(); 
         list.add("item"); 
         String item = list.get(0); 
   
         Set<String> set = new HashSet<String>(); 
         set.add("item"); 
         Map<String, Integer> map = new HashMap<String, Integer>(); 
         map.put("key", 1); 
         int value = map.get("key"); 
// 现在你可以这样： 
         List<String> list = ["item"]; 
         String item = list[0]; 
         
         Set<String> set = {"item"}; 
         
         Map<String, Integer> map = {"key" : 1}; 
         int value = map["key"]; 
```

jdk1.8 新特性：

- HashMap 中链长度大于8时采用红黑树结构存储，因为红黑树除了添加的情况外，其他时候效率比链表高。
- ConcurrentHashMap:底层采用node数组+链表+红黑树的存储结构，通过CAS算法(乐观锁机制)+synchronized来保证并发安全的实现。
- 接口中可以有默认方法与静态方法，也就是接口中可以有实现方法. 默认方法中的default不可省略，子类重写时候，必须去掉default修饰符
- Lambda 表达式: 是对匿名比较器的简化

jdk1.9新特性：

- 在1.8的基础上又增加了接口的私有方法和私有静态方法
- G1是Java 9中的默认GC

jdk1.10新特性：

- 局部变量类型推断:局部变量类型推断将引入"var"关键字，也就是你可以随意定义变量而不必指定变量的类型.
- GC改进和内存管理

```
JDK 10中有2个JEP专门用于改进当前的垃圾收集元素。
 
第一个垃圾收集器接口是（JEP 304），它将引入一个纯净的垃圾收集器接口，以帮助改进不同垃圾收集器的源代码隔离。
 
预定用于Java 10的第二个JEP是针对G1的并行完全GC（JEP 307），其重点在于通过完全GC并行来改善G1最坏情况的等待时间。G1是Java 9中的默认GC，并且此JEP的目标是使G1平行。
```

#### 3. 你用过哪些设计模式，说说这些设计模式的适用场景。


#### 4. 谈谈关于Java的GC机制。

[深入理解Java虚拟机](https://github.com/only3seconds/Notes/blob/master/Java%E8%99%9A%E6%8B%9F%E6%9C%BA.md)

#### 5. 谈谈你对面向对象的理解。

	在我理解,面向对象是一种“万物皆对象”的编程思想。在现实生活中的任何物体都可以归为一类事物，而
	每一个个体都是一类事物的实例。面向对象的编程是以对象为中心，以消息为驱动。
	
面向对象有三大特性，封装、继承和多态。

- 封装

	```
	封装就是将一类事物的属性和行为抽象成一个类，使其属性私有化，行为公开化，提高了数据的隐秘性
	的同时，使代码模块化。这样做使得代码的复用性更高。
	```

- 继承

	```
	继承则是进一步将一类事物共有的属性和行为抽象成一个父类，而每一个子类是一个特殊的父类--有父
	类的行为和属性，也有自己特有的行为和属性。这样做扩展了已存在的代码块，进一步提高了代码的复
	用性。
	```

- 多态

	```
	多态是同一个行为具有多个不同表现形式
	```
	
	- 多态的分类
		
		```
		Java 中的多态分为编译时多态和运行时多态。
		
		编译时多态是静态的，主要是指方法的重载，它是根据参数列表的不同区分不同函数，通过编译之
		后会变成几个不同的函数。
		
		运行时多态是通过动态绑定实现的，是指程序中定义的引用变量所指向的具体类型和通过该引用变
		量发出的方法调用在编程时并不确定，而是在程序运行期间才确定。
		```
		
	- 运行时多态的实现
	
		```
		在Java中有两种形式可以实现多态：继承和接口。
		
		继承：基于继承的实现机制主要表现在父类和继承该父类的一个或多个子类对某些方法的重写，多
		个子类对同一方法的重写可以表现出不同的行为。
		
		接口：在接口的多态中，指向接口的引用必须是指定实现了该接口的一个类的实例，在运行时，根
		据对象引用的实际类型来执行对应的方法。
		
#### 6. 列举出Java至少三种同步机制，并谈谈他们的工作原理。

[Java并发编程](https://github.com/only3seconds/Notes/blob/master/Java%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.md)

	synchronized ReentrantLock ThreadLocal volatile 
	
### SQL 基础

#### 1. 写出能产生下列预期结果的sql语句。

#### 2. SQL的索引方式和他们的实现方式。


