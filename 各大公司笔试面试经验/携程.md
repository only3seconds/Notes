## 携程

### Java 基础

#### 1. 写出快速排序的Java代码，并简单分析其复杂度。

```java
package xiecheng;

import java.util.Arrays;

/**
 * 快速排序 （选取第一个元素作为基准）
 * 时间复杂度：O(nlogn)
 *
 */

public class QuickSort {
    public static void main(String[] args) {
        int[] array = {0, 9, 8, 4, 5, 6, 2, 3, 4};
        System.out.println("排序前： " + Arrays.toString(array));
        quickSort(array, 0, array.length - 1);
        System.out.println("排序后： " + Arrays.toString(array));
    }

    public static void quickSort(int[] array, int left, int right) {
        int pivot;
        if (left < right) {
            pivot = partition(array, left, right);
            quickSort(array, left, pivot - 1);
            quickSort(array, pivot + 1, right);
        }
    }

    public static int partition(int[] array, int left, int right) {
        int key = array[left];
        while (left < right) {
            while (left < right && array[right] >= key) {
                right--;
            }
            array[left] = array[right];
            while (left < right && array[left] <= key) {
                left++;
            }
            array[right] = array[left];
        }
        array[left] = key;
        return left
                ;

    }
}
```

#### 2. 你用过JDK那些版本，为什么要使用这个版本

jdk1.7 新特性：

- switch 中可以使用字符串
- 对集合类的语言支持，存取元素变得方便

```java

// 原本需要这样： 
         List<String> list = new ArrayList<String>(); 
         list.add("item"); 
         String item = list.get(0); 
   
         Set<String> set = new HashSet<String>(); 
         set.add("item"); 
         Map<String, Integer> map = new HashMap<String, Integer>(); 
         map.put("key", 1); 
         int value = map.get("key"); 
// 现在你可以这样： 
         List<String> list = ["item"]; 
         String item = list[0]; 
         
         Set<String> set = {"item"}; 
         
         Map<String, Integer> map = {"key" : 1}; 
         int value = map["key"]; 
```

jdk1.8 新特性：

- HashMap 中链长度大于8时采用红黑树结构存储，因为红黑树除了添加的情况外，其他时候效率比链表高。
- ConcurrentHashMap:底层采用node数组+链表+红黑树的存储结构，通过CAS算法(乐观锁机制)+synchronized来保证并发安全的实现。
- 接口中可以有默认方法与静态方法，也就是接口中可以有实现方法. 默认方法中的default不可省略，子类重写时候，必须去掉default修饰符
- Lambda 表达式: 是对匿名比较器的简化

jdk1.9新特性：

- 在1.8的基础上又增加了接口的私有方法和私有静态方法
- G1是Java 9中的默认GC

jdk1.10新特性：

- 局部变量类型推断:局部变量类型推断将引入"var"关键字，也就是你可以随意定义变量而不必指定变量的类型.
- GC改进和内存管理

```
JDK 10中有2个JEP专门用于改进当前的垃圾收集元素。
 
第一个垃圾收集器接口是（JEP 304），它将引入一个纯净的垃圾收集器接口，以帮助改进不同垃圾收集器的源代码隔离。
 
预定用于Java 10的第二个JEP是针对G1的并行完全GC（JEP 307），其重点在于通过完全GC并行来改善G1最坏情况的等待时间。G1是Java 9中的默认GC，并且此JEP的目标是使G1平行。
```

#### 3. 你用过哪些设计模式，说说这些设计模式的适用场景。

**(1) 单例模式（创建型模式）**

	适用场景：
	1. 资源共享的情况下，避免不一致状态。
		例1，应用程序的日志应用，一般都用单例模式实现，因为共享的日志文件一直处于打开状态，只能有一个实例去操作，否则内容不好追加。
		例2， Web应用的配置对象的读取。
	2. 控制资源的情况下，方便资源之间的互相通信。
		例1，多线程的线程池的设计一般也是采用单例模式，这是由于线程池要方便对池中的线程进行控制。
		例2，数据库连接池的设计一般也是采用单例模式，因为数据库连接是一种数据库资源。数据库软件系统中使用数据库连接池，主要是节省打开或者关闭数据库连接所引起的效率损耗	　　
	特点：
	1、单例类只能有一个实例。
	2、单例类必须自己创建自己的唯一实例。
	3、单例类必须给所有其他对象提供这一实例

- 懒汉模式

```java
/**
 * 单例模式之懒汉模式(线程安全：方法同步）
 */
public class Singleton {
    private Singleton() {}
    private static Singleton singleton = null;
    public static synchronized Singleton getInstance() {
        if(singleton == null) {
            singleton = new Singleton();
        }
        return singleton;
    }
}

/**
 * 单例模式之懒汉模式(线程安全: 双重检查锁定）
 */
public class Singleton {
    private Singleton() {
    }

    private static Singleton singleton = null;

    public static Singleton getInstance() {
        if (singleton == null) {
            synchronized (Singleton.class) {
                if (singleton == null) {
                    singleton = new Singleton();
                }
            }
        }
        return singleton;
    }
}

/**
 * 单例模式之懒汉模式(线程安全：静态内部类，推荐，既保证了线程安全，又避免了同步带来的性能问题）
 */
public class Singleton {
    private Singleton() {
    }

    private static class LazyLoader {
        private static Singleton SINGLETON = new Singleton();
    }

    public static final Singleton getInstance() {
        return LazyLoader.SINGLETON;
    }
    
}

```
- 饿汉模式

```java
/**
 * 单例模式之饿汉模式
 */
public class Singleton {
    private Singleton() {
    }

    private static final Singleton singleton = new Singleton();

    public static final Singleton getInstance() {
        return singleton;
    }

}
```

**(2) 工厂模式（创建型模式）**

- 简单工厂模式

	适用场景：如何能轻松方便地构造对象实例，而不必关心构造对象实例的细节和复杂过程？
	         ---建立一个工厂来创建对象
	

	 
```
 1) 抽象产品角色：它一般是具体产品继承的父类或者实现的接口。         
 2) 具体产品角色：工厂类所创建的对象就是此角色的实例。在java中由一个具体类实现。
 3) 工厂类角色：这是简单工厂模式的核心，用来创建产品
```

- 工厂方法模式


	适用场景：当产品是一个多层次的树状结构时，简单工厂模式中只有一个工厂类来对应这些产品，不能满足要求。

```
 1)抽象产品角色：它是具体产品继承的父类或者是实现的接口。在java中一般有抽象类或者接口来实现。 
 2)具体产品角色：具体工厂角色所创建的对象就是此角色的实例。在java中由具体的类来实现。 
 3)抽象工厂角色： 这是工厂方法模式的核心，它与应用程序无关。是具体工厂角色必须实现的接口或者必须继承的父类。在java中它由抽象类或者接口来实现。 
 4)具体工厂角色：它含有和具体业务逻辑有关的代码。由应用程序调用以创建对应的具体产品的对象。
```   

- 抽象工厂模式

	适用场景：抽象工厂模式是工厂方法模式的升级版本，他用来创建一组相关或者相互依赖的对象。

```
 1)抽象产品族角色: 这是抽象工厂模式的核心，抽象产品的父类，描述抽象产品的公共接口。
 2)抽象产品角色：它是具体产品继承的父类或者是实现的接口。在java中一般有抽象类或者接口来实现。
 抽象产品角色：它是具体产品继承的父类或者是实现的接口。在java中一般有抽象类或者接口来实现。 
 3)具体产品角色：具体工厂角色所创建的对象就是此角色的实例。在java中由具体的类来实现。 
 4)抽象工厂角色： 这是工厂方法模式的核心，它与应用程序无关。是具体工厂角色必须实现的接口或者必须继承的父类。在java中它由抽象类或者接口来实现。 
 5)具体工厂角色：它含有和具体业务逻辑有关的代码。由应用程序调用以创建对应的具体产品的对象。

```

**项目中运用实例：**

**（3）观察者模式（行为型模式）**

- 角色

```
1) 抽象被观察者角色：一般用一个抽象类和接口来实现。把所有对观察者对象的引用保存在一个集合中，每个被观察者角色都可以有任意数量的观察者。被观察者提供一个接口，可以增加和删除观察者角色。
2) 抽象观察者角色：为所有具体的观察者定义一个接口，在得到主题的通知时更新自己。
3) 具体被观察者角色：在被观察者内部状态改变时，给所有登记过的观察者发出通知。具体被观察者角色通常用一个子类实现。
4) 具体观察者角色：该角色实现抽象观察者角色所要求的更新接口，以便使本身的状态与主题的状态相协调。通常用一个子类实现。如果需要，具体观察者角色可以保存一个指向具体主题角色的引用。
```

- 适用场景

```
1) 当一个抽象模型有两个方面, 其中一个方面依赖于另一方面。将这二者封装在独立的对象中以使它们可以各自独立地改变和复用。
2) 当对一个对象的改变需要同时改变其它对象, 而不知道具体有多少对象有待改变。
3) 当一个对象必须通知其它对象，而它又不能假定其它对象是谁。换言之, 你不希望这些对象是紧密耦合的。

```

#### 4. 谈谈关于Java的GC机制。

[深入理解Java虚拟机](https://github.com/only3seconds/Notes/blob/master/Java%E8%99%9A%E6%8B%9F%E6%9C%BA.md)

#### 5. 谈谈你对面向对象的理解。

	在我理解,面向对象是一种“万物皆对象”的编程思想。在现实生活中的任何物体都可以归为一类事物，而
	每一个个体都是一类事物的实例。面向对象的编程是以对象为中心，以消息为驱动。
	
面向对象有三大特性，封装、继承和多态。

- 封装

	```
	封装就是将一类事物的属性和行为抽象成一个类，使其属性私有化，行为公开化，提高了数据的隐秘性
	的同时，使代码模块化。这样做使得代码的复用性更高。
	```

- 继承

	```
	继承则是进一步将一类事物共有的属性和行为抽象成一个父类，而每一个子类是一个特殊的父类--有父
	类的行为和属性，也有自己特有的行为和属性。这样做扩展了已存在的代码块，进一步提高了代码的复
	用性。
	```

- 多态

	```
	多态是同一个行为具有多个不同表现形式
	```
	
	- 多态的分类
		
		```
		Java 中的多态分为编译时多态和运行时多态。
		
		编译时多态是静态的，主要是指方法的重载，它是根据参数列表的不同区分不同函数，通过编译之
		后会变成几个不同的函数。
		
		运行时多态是通过动态绑定实现的，是指程序中定义的引用变量所指向的具体类型和通过该引用变
		量发出的方法调用在编程时并不确定，而是在程序运行期间才确定。
		```
		
	- 运行时多态的实现
	
		```
		在Java中有两种形式可以实现多态：继承和接口。
		
		继承：基于继承的实现机制主要表现在父类和继承该父类的一个或多个子类对某些方法的重写，多
		个子类对同一方法的重写可以表现出不同的行为。
		
		接口：在接口的多态中，指向接口的引用必须是指定实现了该接口的一个类的实例，在运行时，根
		据对象引用的实际类型来执行对应的方法。
		
#### 6. 列举出Java至少三种同步机制，并谈谈他们的工作原理。


