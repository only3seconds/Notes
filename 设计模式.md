# 设计模式

## 单例模式（创建型模式）

	适用场景：
	1. 资源共享的情况下，避免不一致状态。
		例1，应用程序的日志应用，一般都用单例模式实现，因为共享的日志文件一直处于打开状态，只能有一个实例去操作，否则内容不好追加。
		例2， Web应用的配置对象的读取。
	2. 控制资源的情况下，方便资源之间的互相通信。
		例1，多线程的线程池的设计一般也是采用单例模式，这是由于线程池要方便对池中的线程进行控制。
		例2，数据库连接池的设计一般也是采用单例模式，因为数据库连接是一种数据库资源。数据库软件系统中使用数据库连接池，主要是节省打开或者关闭数据库连接所引起的效率损耗	　　
	特点：
	1、单例类只能有一个实例。
	2、单例类必须自己创建自己的唯一实例。
	3、单例类必须给所有其他对象提供这一实例

- 懒汉模式

```java
/**
 * 单例模式之懒汉模式(线程安全：方法同步）
 */
public class Singleton {
    private Singleton() {}
    private static Singleton singleton = null;
    public static synchronized Singleton getInstance() {
        if(singleton == null) {
            singleton = new Singleton();
        }
        return singleton;
    }
}

/**
 * 单例模式之懒汉模式(线程安全: 双重检查锁定）
 */
public class Singleton {
    private Singleton() {
    }

    private static Singleton singleton = null;

    public static Singleton getInstance() {
        if (singleton == null) {
            synchronized (Singleton.class) {
                if (singleton == null) {
                    singleton = new Singleton();
                }
            }
        }
        return singleton;
    }
}

/**
 * 单例模式之懒汉模式(线程安全：静态内部类，推荐，既保证了线程安全，又避免了同步带来的性能问题）
 */
public class Singleton {
    private Singleton() {
    }

    private static class LazyLoader {
        private static Singleton SINGLETON = new Singleton();
    }

    public static final Singleton getInstance() {
        return LazyLoader.SINGLETON;
    }
    
}

```
- 饿汉模式

```java
/**
 * 单例模式之饿汉模式
 */
public class Singleton {
    private Singleton() {
    }

    private static final Singleton singleton = new Singleton();

    public static final Singleton getInstance() {
        return singleton;
    }

}
```

## 工厂模式（创建型模式）

### 1. 简单工厂模式

	适用场景：如何能轻松方便地构造对象实例，而不必关心构造对象实例的细节和复杂过程？
	         ---建立一个工厂来创建对象
	

	 
```
 1) 抽象产品角色：它一般是具体产品继承的父类或者实现的接口。         
 2) 具体产品角色：工厂类所创建的对象就是此角色的实例。在java中由一个具体类实现。
 3) 工厂类角色：这是简单工厂模式的核心，用来创建产品
```
### 2. 工厂方法模式


	适用场景：当产品是一个多层次的树状结构时，简单工厂模式中只有一个工厂类来对应这些产品，不能满足要求。

```
 1)抽象产品角色：它是具体产品继承的父类或者是实现的接口。在java中一般有抽象类或者接口来实现。 
 2)具体产品角色：具体工厂角色所创建的对象就是此角色的实例。在java中由具体的类来实现。 
 3)抽象工厂角色： 这是工厂方法模式的核心，它与应用程序无关。是具体工厂角色必须实现的接口或者必须继承的父类。在java中它由抽象类或者接口来实现。 
 4)具体工厂角色：它含有和具体业务逻辑有关的代码。由应用程序调用以创建对应的具体产品的对象。
```   

### 3. 抽象工厂模式

	适用场景：抽象工厂模式是工厂方法模式的升级版本，他用来创建一组相关或者相互依赖的对象。

```
 1)抽象产品族角色: 这是抽象工厂模式的核心，抽象产品的父类，描述抽象产品的公共接口。
 2)抽象产品角色：它是具体产品继承的父类或者是实现的接口。在java中一般有抽象类或者接口来实现。
 抽象产品角色：它是具体产品继承的父类或者是实现的接口。在java中一般有抽象类或者接口来实现。 
 3)具体产品角色：具体工厂角色所创建的对象就是此角色的实例。在java中由具体的类来实现。 
 4)抽象工厂角色： 这是工厂方法模式的核心，它与应用程序无关。是具体工厂角色必须实现的接口或者必须继承的父类。在java中它由抽象类或者接口来实现。 
 5)具体工厂角色：它含有和具体业务逻辑有关的代码。由应用程序调用以创建对应的具体产品的对象。

```

## 观察者模式（行为型模式）

### 1. 角色

```
1) 抽象被观察者角色：一般用一个抽象类和接口来实现。把所有对观察者对象的引用保存在一个集合中，每个被观察者角色都可以有任意数量的观察者。被观察者提供一个接口，可以增加和删除观察者角色。
2) 抽象观察者角色：为所有具体的观察者定义一个接口，在得到主题的通知时更新自己。
3) 具体被观察者角色：在被观察者内部状态改变时，给所有登记过的观察者发出通知。具体被观察者角色通常用一个子类实现。
4) 具体观察者角色：该角色实现抽象观察者角色所要求的更新接口，以便使本身的状态与主题的状态相协调。通常用一个子类实现。如果需要，具体观察者角色可以保存一个指向具体主题角色的引用。
```

### 2. 适用场景

```
1) 当一个抽象模型有两个方面, 其中一个方面依赖于另一方面。将这二者封装在独立的对象中以使它们可以各自独立地改变和复用。
2) 当对一个对象的改变需要同时改变其它对象, 而不知道具体有多少对象有待改变。
3) 当一个对象必须通知其它对象，而它又不能假定其它对象是谁。换言之, 你不希望这些对象是紧密耦合的。

```