# MySQL

## 一. 事务

### 1. 事务的特性
**** 

**什么是事务？**

事务指的是满足 ACID 特性的一组操作，可以通过 Commit 提交一个事务，也可以使用 Rollback 进行回滚。

**为什么需要事务？**

为了保证数据的完整性。事务就是为了解决数据安全操作提出的，事务控制实际上就是控制数据的安全访
问。

**ACID**

![](https://img-blog.csdnimg.cn/20190321140442474.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pvdXJuZXlfVHJpcGxlUA==,size_16,color_FFFFFF,t_70)

- 原子性（Atomicity）
事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。回滚可以用回滚日志来实现，回滚日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。

- 一致性（Consistency）
数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对一个数据的读取结果都是相同的。

- 隔离性（Isolation）
一个事务所做的修改在最终提交以前，对其它事务是不可见的。

- 持久性（Durability）
一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。使用重做日志来保证持久性。

### 2. 并发一致性问题
****

**为什么会有并发一致性问题？**

在并发环境下，事务的隔离性很难保证，因此会出现很多并发一致性问题：

- 丢失修改： T1 和 T2 两个事务都对一个数据进行修改，T1 先修改，T2 随后修改，T2 的修改覆盖了 T1 的修改。

![](https://img-blog.csdnimg.cn/20190321142034741.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pvdXJuZXlfVHJpcGxlUA==,size_16,color_FFFFFF,t_70)

- 脏读：T1 修改一个数据，T2 随后读取这个数据。如果 T1 撤销了这次修改，那么 T2 读取的数据是脏数据。

![](https://img-blog.csdnimg.cn/2019032114151899.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pvdXJuZXlfVHJpcGxlUA==,size_16,color_FFFFFF,t_70)

- 不可重复读：T2 读取一个数据，T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同。

![](https://img-blog.csdnimg.cn/20190321141801423.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pvdXJuZXlfVHJpcGxlUA==,size_16,color_FFFFFF,t_70)


- 幻读：T1 读取某个范围的数据，T2 在这个范围内插入新的数据，T1 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同，仿佛产生了幻觉。
	
![](https://img-blog.csdnimg.cn/20190321142226406.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pvdXJuZXlfVHJpcGxlUA==,size_16,color_FFFFFF,t_70)

**如何解决并发一致性问题？**

	通过并发控制来保证隔离性，并发控制可以通过封锁来实现，但是封锁操作需要用户自己控制，相当复
	杂。数据库管理系统提供了事务的隔离级别，让用户以一种更轻松的方式处理并发一致性问题。
	
### 3. 封锁
****

**封锁粒度**

MySQL 中提供了两种封锁粒度：行级锁以及表级锁。

- 行级锁：每次操作锁住一行数据。开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高；

- 表级锁：每次操作锁住整张表。开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低；

在选择封锁粒度时，需要在锁开销和并发程度之间做一个权衡。

**封锁类型**

（1）读写锁

- 排它锁（Exclusive），简写为 X 锁，又称写锁。
- 共享锁（Shared），简写为 S 锁，又称读锁。

（2）意向锁

意向锁在原来的 X/S 锁之上引入了 IX/IS，IX/IS 都是表锁，用来表示一个事务想要在表中的某个数据行上加 X 锁或 S 锁。有以下两个规定：

- 一个事务在获得某个数据行对象的 S 锁之前，必须先获得表的 IS 锁或者更强的锁；
- 一个事务在获得某个数据行对象的 X 锁之前，必须先获得表的 IX 锁。

通过引入意向锁，事务 T 想要对表 A 加 X 锁，只需要先检测是否有其它事务对表 A 加了 X/IX/S/IS 锁

![](https://img-blog.csdnimg.cn/20190321150448559.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pvdXJuZXlfVHJpcGxlUA==,size_16,color_FFFFFF,t_70)

**封锁协议**

（1）三级封锁协议

- 一级封锁协议: 事务 T 要修改数据 A 时必须加 X 锁，直到 T 结束才释放锁。可以解决丢失修改问题,因为不能同时有两个事务对同一个数据进行修改，那么事务的修改就不会被覆盖。
	
- 二级封锁协议: 在一级的基础上，要求读取数据 A 时必须加 S 锁，读取完马上释放 S 锁。可以解决读脏数据问题。因为如果一个事务在对数据 A 进行修改，根据 1 级封锁协议，会加 X 锁，那么就不能再加 S 锁了，也就是不会读入数据。
	
- 三级封锁协议: 在二级的基础上，要求读取数据 A 时必须加 S 锁，直到事务结束了才能释放 S 锁。
可以解决不可重复读的问题，因为读 A 时，其它事务不能对 A 加 X 锁，从而避免了在读的期间数据发生改变。

（2）两段锁协议

- 两段锁协议：一个事务中一旦开始释放锁，就不能再申请新锁了。事务的加锁和解锁严格分为两个阶段，第一阶段加锁，第二阶段解锁。

- 可串行化调度：通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同。

- 事务遵循两段锁协议 -> 可串行化调度，反之不一定

### 4. 事务的隔离级别

- Read Uncommitted(未提交读）：会读取到未提交的数据。没有解决任何问题。但这种模式也不
是说完全没加锁，在读取时是不会加锁的，但在更新数据时，对其加行级共享锁（其它事务不能更改，但
可以读取，导致脏读），事务结束时释放。

- Read Committed（提交读）：读取的数据是已提交成功的。解决了脏读问题。解决方式是给写数
据加行级排他锁，这样写过程是无法读取的，直到事务处理完毕才释放排他锁，给读的数据加行级共享
锁，这样读的时候也是无法写的，但是一旦读完该行就释放共享锁。这种模式下虽然处理了脏读，但是并
没有处理丢失更新和不可重复读的问题。

- Repeatable Read(可重复读）：可以重复读取数据。解决了不可重复读和更新丢失问题。解决办
法：给写的数据加行级排他锁，事务结束释放，给读的数据加行级共享锁，事务结束后释放。

- Serializable（序列化）：事务读数据则加表级共享锁，事务写数据则加表级排他锁，幻读问题也得到了解决。

### 5. 多版本并发控制

	多版本并发控制（Multi-Version Concurrency Control, MVCC）是 MySQL 的 InnoDB 存储
	引擎实现隔离级别的一种具体方式，用于实现提交读和可重复读这两种隔离级别。而未提交读隔离级别总
	是读取最新的数据行，无需使用 MVCC。可串行化隔离级别需要对所有读取的行都加锁，单纯使用 MVCC 
	无法实现。
	
**版本号**

- 系统版本号：是一个递增的数字，每开始一个新的事务，系统版本号就会自动递增。
- 事务版本号：事务开始时的系统版本号。

**隐藏的列**

MVCC 在每行记录后面都保存着两个隐藏的列，用来存储两个版本号：

- 创建版本号：指示创建一个数据行的快照时的系统版本号；
- 删除版本号：如果该快照的删除版本号大于当前事务版本号表示该快照有效，否则表示该快照已经被删除了。

## 二. 索引

索引是在存储引擎层实现的，而不是在服务器层实现的，所以不同存储引擎具有不同的索引类型和实现。

### 1. B 树 & B+ 树

**数据结构**

- B 树, 指的是 Balance Tree，也就是平衡树。平衡树是一颗查找树，并且所有叶子节点位于同一层。

- B+ 树, 基于 B 树和叶子节点顺序访问指针进行实现，它具有 B 树的平衡性，并且通过顺序访问指针来提高区间查询的性能。在 B+ 树 中，一个节点中的 key 从左到右非递减排列。

### 2. 索引的原则

**最左前缀匹配原则** 

mysql会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配

	比如state='yes' and city='wuwei' and price > 3 and name = 'ppp' 如果建立
	(state, city, price, name)顺序的索引，name的查询是用不到索引的，只能使用部分索引，然后
	在结果集上面进行排序。如果建立(state, city , name, price)的索引则都可以用到，state,
	city, name的顺序可以任意调整。
	
**= 和 in可以乱序**

	比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优
	化成索引可以识别的形式。但是如果建立索引(a,b,c)，结果where子句是:b =2 and c=3，则索引不
	起作用。

### 3. 索引的优点

- 大大加快数据的检索速度，这是创建索引的最主要的原因
- 创建唯一性索引，保证数据库表中每一行数据的唯一性
- 加速数据库表之间的连接，特别是在实现数据的参考完整性方面特别有意义
- 在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间
- 通过使用索引，可以在查询中使用优化隐藏器，提高系统的性能

### 4. 索引的缺点

- 创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加
- 索引需要占用物理空间，除了数据表占用数据空间之外，每一个索引还要占一定的物理空间，如果建立聚簇索引，那么需要的空间就会更大
- 当对表中的数据进行增加、删除和修改的时候，索引也需要维护，降低数据维护的速度

### 5. 索引失效

- 如果MySQL估计使用全表扫秒比使用索引快，则不使用索引；
- 如果条件中有or，即使其中有条件带索引也不会使用；
- 复合索引，如果索引列不是复合索引的第一部分，则不使用索引（即不符合最左前缀）；
- 如果like是以 % 开始的，则该列上的索引不会被使用；
- 如果列为字符串，则where条件中必须将字符常量值加引号，否则即使该列上存在索引，也不会被使用；

### 6. 在什么情况下适合建立索引

- 为经常出现在关键字order by、group by、distinct后面的字段，建立索引；
- 在union等集合操作的结果集字段上，建立索引；
- 为经常用作查询选择 where 后的字段，建立索引；
- 在经常用作表连接 join 的属性上，建立索引；
- 考虑使用索引覆盖。对数据很少被更新的表，如果用户经常只查询其中的几个字段，可以考虑在这几个字段上建立索引，从而将表的扫描改变为索引的扫描。

## 三. 查询性能优化
## 四. 分库分表

# Redis



# SQL

### 1. 创建数据库

	CREATE DATABASE test;
	
### 2. 使用数据库

	USE test;
	
### 3. 创建表
	
	CREATE TABLE Orders
	(
	Id_O int NOT NULL,
	OrderNo int NOT NULL,
	Id_P int,
	PRIMARY KEY (Id_O),
	CONSTRAINT fk_PerOrders FOREIGN KEY (Id_P) REFERENCES Persons(Id_P)
	)
	
	
### 4. 向表中插入数据

	INSERT INTO Student (学号，姓名，年龄，性别，联系电话，学历)
	VALUES（1，‘a’,’22’，‘男’，‘123456’，‘小学’），
		  （2，‘b’,’21’，‘男’，‘119’，‘中学’），
		  （3，‘b’,’23，‘男’，‘110’，‘高中’），
		  （4，‘b’,’18，‘女’，‘114’，‘大学’）；

### 5. 查询表中数据