# 深入理解Java虚拟机

![](https://img-blog.csdnimg.cn/2019022114204285.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pvdXJuZXlfVHJpcGxlUA==,size_16,color_FFFFFF,t_70)

## 一. 运行时数据区域


### 1. 程序计数器
	程序计数器可以看作当前线程执行的字节码的行号指示器
- 如果线程正在执行的是一个 Java 方法，这个计数器记录的是当前线程正在执行的字节码的指令的地址
- 如果线程正在执行的是一个 Native 方法，这个计数器则为空
- 这个内存区域是唯一一个没有规定 OutOfMemoryError 情况的区域

### 2. Java 虚拟机栈
	JVM 栈描述的是 Java 方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧（Stack 
	Frame)用于存储局部变量表、操作数栈、动态链接、方法出口等信息。
- 每一个方法从调用直至完成的过程，就对应着一个栈帧在虚拟机栈中入栈出栈的过程
- 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出 StackOverflowError 
- 如果虚拟机扩展时无法申请到足够的内存，将抛出 OutOfMemoryError

### 3. 本地方法栈
	Java虚拟机栈为虚拟机执行 java 方法（也就是字节码） 服务，而本地方法栈则是为虚拟机使用到的 
	Native 方法服务
- Native 方法：调用非 java 代码的接口

### 4. Java 堆
	此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存
- Java 堆是垃圾收集器管理的主要区域
- Java 堆可以处于物理上不连续的内存空间上，但逻辑上一定要连续
- Java堆又分为： 新生代、老年代
- 如果在 java 堆中没有内存完成实例分配，并且堆也无法再扩展，将抛出 OutOfMemoryError

### 5. 方法区
	方法区用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等。
	方法区又叫永久代

#### 运行时常量池
	用于存放编译期生成的各种字面量和符号引用
	
### 6. 直接内存
	在 JDK 1.4 中新加入了 NIO 类，它可以使用 Native 函数库直接分配堆外内存，然后通过一个存储
	在 Java 堆里的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著
	提高性能，因为避免了在 Java 堆和 Native 堆中来回复制数据。
	
## 二. 垃圾回收机制
	垃圾收集主要是针对堆和方法区进行。
	
	程序计数器、虚拟机栈和本地方法栈这三个区域属于线程私有的，只存在于线程的生命周期内，线程结束
	之后也会消失，因此不需要对这三个区域进行垃圾回收。垃圾回收主要是针对 Java 堆和方法区进行。
	
### 1. 判断一个对象是否可被回收---可达性分析

（1）引用计数法

- 描述：给对象中添加一个引用计数器每当有一个地方引用它时，计数器就加1；当引用失效时，计数器值
	就减1；任何时刻计数器为0的对象就是不可能在被使用的。

- 缺陷：很难解决对象间相互循环引用的问题
[内存回收中引用计数算法的循环引用问题](https://blog.csdn.net/Chuan73/article/details/80064297)

（2） 可达性分析算法

	将 GC Roots 作为起始点进行搜索，可达的对象都是存活的，不可达的对象可被回收。

Java 虚拟机使用该算法来判断对象是否可被回收，在 Java 中 GC Roots 一般包含以下内容：

- 虚拟机栈中局部变量表中引用的对象
- 本地方法栈中 JNI 中引用的对象
- 方法区中类静态属性引用的对象
- 方法区中的常量引用的对象

（3）方法区的回收
	主要是对常量池的回收和对类的卸载。
	为了避免内存溢出，在大量使用反射、动态代理的场景都需要虚拟机具备类卸载功能。
	
类的卸载条件很多，需要满足以下三个条件，但是满足了也不一定会被卸载：

- 该类所有的实例都已经被回收，此时堆中不存在该类的任何实例。
- 加载该类的 ClassLoader 已经被回收。
- 该类对应的 Class 对象没有在任何地方被引用，也就无法在任何地方通过反射访问该类方法。

	
（4）finalize
	当一个对象可被回收时，如果需要执行该对象的 finalize() 方法，那么就有可能在该方法中让对象重
	新被引用，从而实现自救。自救只能进行一次，如果回收的对象之前调用了 finalize() 方法自救，后
	面回收时不会再调用该方法。
	
### 2. 垃圾收集算法---分代收集
一般将堆分为新生代和老年代。

- 新生代使用：复制算法
```
HotSpot 虚拟机的 Eden 和 Survivor 大小比例默认为 8:1，每次使用 Eden 和其中一块 
Survivor。在回收时，将 Eden 和 Survivor 中还存活着的对象全部复制到另一块 Survivor 上，
最后清理 Eden 和使用过的那一块 Survivor,保证了内存的利用率达到 90%。如果每次回收有多于 10%
的对象存活，那么一块 Survivor 就不够用了，此时需要依赖于老年代进行空间分配担保，也就是借用老年
代的空间存储放不下的对象。
```

- 老年代使用：标记 - 清除 或者 标记 - 整理 算法

### 3. 垃圾收集器--G1收集器


## 三. 内存分配与回收策略

### 1. Minor GC 和 Full GC

- Minor GC：发生在新生代上，因为新生代对象存活时间很短，因此 Minor GC 会频繁执行，执行的速度
一般也会比较快。
	- 新生代中的垃圾收集动作，采用的是复制算法
	- 对于较大的对象，在 Minor GC 的时候可以直接进入老年代
	
- Full GC：发生在老年代上，老年代对象其存活时间长，因此 Full GC 很少执行，执行速度会比 Minor GC 慢很多。
	- Full GC 是发生在老年代的垃圾收集动作，采用的是 标记-清除/整理 算法。
	- 由于老年代的对象几乎都是在 Survivor 区熬过来的，不会那么容易死掉。因此 Full GC 发生的次数不会有 Minor GC 那么频繁，并且 Time(Full GC)>Time(Minor GC)


### 2. 内存分配策略

- 对象优先在 Eden 分配，Eden空间不够，发起 Minor GC.

- 大对象直接进入老年代，避免在 Eden 区和 Survivor 区之间的大量内存复制。大对象是指需要连续内
存空间的对象，最典型的大对象是那种很长的字符串以及数组。

- 长期存活的对象进入老年代

- 动态对象年龄判定：如果在 Survivor 中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代。

- 空间分配担保

	```
	使用复制算法的 Minor GC 需要老年代的内存空间作担保, 在 Minor GC 之前，虚拟机先检查老年代
	最大可用的连续空间是否大于新生代所有对象总空间，如果大于，那么 Minor GC 可以确认是安全的。
	如果小于，虚拟机会查看 HandlePromotionFailure 设置值是否允许担保失败，如果允许那么就会
	继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进
	行一次 Minor GC；如果小于，或者 HandlePromotionFailure 设置不允许冒险，那么就要进行一
	次 Full GC。
	```

### 3. 什么时候触发Full GC?

- 调用 System.gc() 但不一定触发

- 老年代空间不足

- 空间担保失败







	


