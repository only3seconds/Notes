# 一. 分布式 & 集群
## 1.分布式
	分布式是将一个业务拆分成多个子业务，不同的子业务部署在不同的服务器上。（不同的服务器运行不同
	的代码，为了同一个目的），某个节点垮了，那这个业务就不能访问了。
	
	分布式是以缩短单个任务的执行时间来提升效率的。

	
## 2.集群
	集群将几台服务器集中在一起，实现同一业务。（不同的服务器运行相同的代码，干同一件事）。分布式
	中的每一个节点都可以做集群。
	
	集群是通过提高单位时间内执行的任务数来提升效率的。

### 两大关键特性
- 可扩展性：新的服务实体可以动态地加入集群，从而加强集群的性能
- 高可用性（HA）：在集群中，同样的服务可以由多个服务实体提供，如果一个服务实体失败了，另一个服务实体会接管该服务实体

### 两大能力
- 负载均衡：将任务比较均衡地分布在集群环境中的计算或网络资源
- 错误恢复：由于某种原因，一个服务实体中的资源执行任务出现故障，另一个实体中的资源透明地继续执行这个任务叫错误恢复

### 两大技术
- 集群地址：具有单一集群地址是集群的一个基本特征。客户端通过集群地址获取集群内的各服务实体的功能。维护集群地址的设置被称为负载均衡器，负载均衡器内部负责各个服务实体的加入和删除；外部负责集群地址向服务实体地址的映射
- 内部通信：集群内的服务实体需要进行内部通信，以实现协同工作，负载均衡和错误恢复。比如负载均衡器对服务实体心跳检测信息，服务实体间任务执行上下文信息的通信。

### 集群分类
- 高可用集群（High Availability Cluster）：高可用集群为了保障用户的应用程序持续对外提供服务，不是用来保护业务数据的，把因软件/硬件/人为造成的故障对业务的影响降低到最小程度。
-  负载均衡集群(Load Balance Cluster)：负载均衡系统指集群中所有的节点都处于活动状态，它们分摊系统的工作负载。一般Web服务器集群、数据库集群和应用服务器集群都属于这种类型。
-  科学计算集群(High Performance Computing Cluster)：这类集群致力于提供单个计算机所不能提供的强大的计算能力。

# 二. 并行并发 & 同步异步 & 多线程
## 1.并行
	多处理器的情况下，多个进程在同一时刻运行。

## 2.并发
	对于同一个处理器，多个进程在某个时间段内，都处于已启动运行到运行完毕之间的状态。
	其中，进程间有两种并发关系：同步和互斥。

## 3.同步 & 互斥 
- 同步：并发的进程间是依赖关系，前一个进程的输出是后一个进程的输入，相互协同完成一些事情。当第一个进程没有结束时第二个进程必须等待。具有同步关系的一组进程并发时发送的消息称为消息或事件。

- 互斥：并发的进程间相互排斥使用临界资源。

## 4.异步 & 多线程
- 异步：并发的进程间是依赖关系，前一个进程的输出是后一个进程的输入，相互协同完成一些事情。当第一个进程没有结束时，第二个进程无需傻傻等待第一个进程的结果，而是可以继续做自己的事情。线程就是实现异步的一个方式。异步是让调用方法的主线程不需要同步等待另一个线程的完成，之间通过消息或事件来通知对方，从而可以让主线程干其他的事情。

- 多线程：多线程是程序设计的逻辑层概念，它是进程中并发运行的一段代码。多线程只是实现异步的一种手段。	

# 三. 分布式一致性问题

## 1. CAP 理论
CAP（或称布鲁尔定理）指出一个分布式计算系统不可能同时满足以下三点：

- 一致性（Consistency）：所有节点拥有数据的最新版本；

- 可用性（Availability）：每次请求都能获取非错的响应，但无法保证获取的数据是否最新；

- 分区容忍性（Partition tolerance）：网络分区指分布式系统中的各个节点，任意分区（节点）网络故障时，系统仍需要可以对外提供服务。

分布式系统不可能同时满足这三个特性，最多只能同时满足其中两项，分区容忍性必不可少，因为需要总是假设网络不是可靠的，所以最终要在可用性和一致性之间做选择。

**理解：**

	一个分布式系统里面，节点组成的网络本来应该是连通的。然而可能因为一些故障，使得有些节点之间不
	连通了，整个网络就分成了几块区域。数据就散布在了这些不连通的区域中。这就叫分区。
	
	当你一个数据项只在一个节点中保存，那么分区出现后，和这个节点不连通的部分就访问不到这个数据
	了。这时分区就是无法容忍的。提高分区容忍性的办法就是一个数据项复制到多个节点上，那么出现分区
	之后，这一数据项就可能分布到各个区里。容忍性就提高了。然而，要把数据复制到多个节点，就会带来
	一致性的问题，就是多个节点上面的数据可能是不一致的。要保证一致，每次写操作就都要等待全部节点
	写成功，而这等待又会带来可用性的问题。
	
	总的来说就是，数据存在的节点越多，分区容忍性越高，但要复制更新的数据就越多，一致性就越难保
	证。为了保证一致性，更新所有节点数据所需要的时间就越长，可用性就会降低。

[CAP理论中的P到底是个什么意思？](https://www.zhihu.com/question/54105974/answer/139037688)

## 2. BASE 理论

BASE理论，它是用来对CAP定理进行进一步扩充的，为了实现高可用。

BASE中的三要素：

- 基本可用（Basically Available）：基本可用是指分布式系统在出现不可预知故障的时候，允许损失部分可用性----注意，这绝不等价于系统不可用。

- 软状态（Soft state）：软状态指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时；

- 最终一致性（Eventually consistent）：最终一致性强调的是所有的数据副本，在经过一段时间的同步之后，最终都能够达到一个一致的状态。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性。

## 3. 分布式事务

**如何实现分布式一致性，即如何实现分布式事务？**

### (1) 两阶段提交 （2PC / XA Transactions）

![](https://img-blog.csdnimg.cn/20190328163200131.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pvdXJuZXlfVHJpcGxlUA==,size_16,color_FFFFFF,t_70)

- 第一阶段：事务协调器要求每个涉及到事务的数据库预提交(precommit)此操作，并反映是否可以提交；
- 第二阶段：事务协调器要求每个数据库提交数据。

	其中，如果有任何一个数据库否决此次提交，那么所有数据库都会被要求回滚它们在此事务中的那部分信息。牺牲了一部分可用性来换取的一致性。
	
**优点**：尽量保证了数据的强一致，适合对数据强一致要求很高的关键领域；

**缺点**：实现复杂，牺牲了可用性，对性能影响较大，不适合高并发高性能场景。

### (2) 补偿事务（TCC）
****

TCC 其实就是采用的补偿机制，其核心思想是：针对每个操作，都要注册一个与其对应的确认和补偿（撤销）操作。它分为三个阶段：

- Try 阶段主要是对业务系统做检测及资源预留;

- Confirm 阶段主要是对业务系统做确认提交;

- Cancel 阶段主要是在业务执行错误，需要回滚的状态下执行的业务取消，预留资源释放。

**优点**：跟2PC比起来，实现以及流程相对简单了一些，但数据的一致性比2PC也要差一些

**缺点**：在2,3步中都有可能失败。TCC属于应用层的一种补偿方式，所以需要程序员在实现的时候多写很多补偿的代码。

###  (3) 本地消息表（异步确保）
****

本地消息表这种实现方式应该是业界使用最多的，其核心思想是将分布式事务拆分成本地事务进行处理

![](https://images2017.cnblogs.com/blog/250417/201710/250417-20171016141237443-2074834323.png)

消息生产方，需要额外建一个消息表，并记录消息发送状态。消息表和业务数据要在一个事务里提交，也就是说他们要在一个数据库里面。然后消息会经过MQ（消息队列）发送到消息的消费方。如果消息发送失败，会进行重试发送。

消息消费方，需要处理这个消息，并完成自己的业务逻辑。此时如果本地事务处理成功，表明已经处理成功了，如果处理失败，那么就会重试执行。如果是业务上面的失败，可以给生产方发送一个业务补偿消息，通知生产方进行回滚等操作。

生产方和消费方定时扫描本地消息表，把还没处理完成的消息或者失败的消息再发送一遍。

**优点**：避免了分布式事务，实现了最终一致性

**缺点**：消息表会耦合到业务系统中，如果没有封装好的解决方案，会有很多杂活需要处理。

### (4) MQ 事务消息
****

有一些第三方的MQ是支持事务消息的，比如RocketMQ，他们支持事务消息的方式也是类似于采用的二阶段提交。

以阿里的 RocketMQ 中间件为例，其思路大致为：

第一阶段Prepared消息，会拿到消息的地址。
第二阶段执行本地事务，第三阶段通过第一阶段拿到的地址去访问消息，并修改状态。

**优点**：实现了最终一致性，不需要依赖本地数据库事务。

**缺点**：实现难度大，主流MQ不支持，没有.NET客户端，RocketMQ事务消息部分代码也未开源。

# 四. 分布式环境中并发问题

## 1. 避免并发

	在分布式环境中，如果存在并发问题，那么很难通过技术去解决，或者解决的代价很大，所以我们首先要
	想想是不是可以通过某些策略和业务设计来避免并发。比如通过合理的时间调度，避开共享资源的存取冲
	突。另外，在并行任务设计上可以通过适当的策略，保证任务与任务之间不存在共享资源。
	
## 2. 时间戳

	比如系统A需要把某个值的变更同步到系统B，由于通知的时序问题会导致一个过期的值覆盖了有效值。对
	于这个问题，常用的办法就是采用时间戳的方式，每次系统A发送变更给系统B的时候需要带上一个能标示
	时序的时间戳，系统B接到通知后会拿时间戳与存在的时间戳比较，只有当通知的时间戳大于存在的时间
	戳，才做更新。
	
## 3. 串行化

	当接收方没法处理调用有序性，可以通过一个队列先把调用信息缓存起来，然后再串行地处理这些调用。
	
## 4. 数据库

	数据库是分布式各服务器的共享点，可以通过数据库的高可靠一致性机制来满足需求。比如，可以通过唯
	一性索引来解决并发过程中重复数据的生产或重复任务的执行。另外有些更新计算操作也尽量通过sql来
	完成，因为在程序段计算好后再去更新就有可能发生脏复写问题，但通过一条sql来完成计算和更新就可
	以通过数据库的锁机制来保证update操作的一致性。
	
## 5. 行锁

	有的事务比较复杂，无法通过一条sql解决问题，并且有存在并发问题，这时就需要通过行锁来解决，一
	般行锁可以通过以下方式来实现：
	
	InnoDB行锁是通过给索引上的索引项加锁来实现的，这一点MySQL与Oracle不同，后者是通过在数据块
	中对相应数据行加锁来实现的。InnoDB这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB
	才使用行级锁，否则，InnoDB将使用表锁！

	
## 6. 统一触发途径

	当一个数据可能会被多个触发点或多个业务涉及到，就有并发问题产生的隐患，因此可以通过前期架构和
	业务设计，尽量统一触发途径，触发途径少了一是减少并发的可能，也有利于对于并发问题的分析和判
	断。
	
### 参考资料

[聊聊分布式事务，再说说解决方案](https://www.cnblogs.com/savorboard/p/distributed-system-transaction-consistency.html)

[RocketMQ支持事务消息机制](https://www.jianshu.com/p/cc5c10221aa1)