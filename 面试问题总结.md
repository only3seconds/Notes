# Java 基础


### 面向对象和基于对象的区别？

### 说出Object类的常用方法？
	1.public final native Class<?> getClass()
	getClass方法用于获得一个对象的类型类
	
	2.public String toString()
	默认返回 ToStringExample@4554617c 这种形式，其中 @ 后面的数值为散列码的无符号十六进制
	表示。
	
	3.public boolean equals(Object obj)
	equals 与 == 的区别
	对于==方法，如果作用于基本数据类型的变量，则直接比较其存储的 “值”是否相等；如果作用于引用
	类型的变量，则比较的是所指向的对象的地址是否相同，即是否指向同一个对象；
	对于equals方法，注意：equals方法不能作用于基本数据类型的变量。如果没有对equals方法进行重
	写，则比较的是引用类型的变量所指向的对象的地址是否相同；诸如String、Date等类对equals方法
	进行了重写的话，比较的是所指向的对象的内容是否相同。
		
	4.public native int hashCode()
	(1) hasCode() 返回散列值，而 equals() 是用来判断两个实例是否等价。等价的两个实例散列值
	定要相同，但是散列值相同的两个实例不一定等价。
	(2) 在覆盖 equals() 方法时应当总是覆盖 hashCode() 方法，保证等价的两个实例散列值也相等
	
	5.void wait()
	使当前执行代码的线程进行等待，直到接到通知或者被中断。每个锁对象都有两个队列，分别是就绪队列
	和阻塞队列，一个线程被 wait 后就会进入阻塞队列。
	wait()方法执行后立即释放锁。
	wait(long) 等待某一时间内是否有线程对锁进行唤醒，如果超过这个时间则自动唤醒。
		
	6.void notify()
	随机唤醒在此对象监视器上等待的单个线程。 
	当方法notify()被执行后，锁不自动释放，必须执行完notify（）所在的synchronized代码块后才
	释放锁
	
	7.void notifyAll()
	唤醒在此对象监视器上等待的所有线程。
	
	8.protected Object clone()
	创建并返回此对象的一个副本。（可以实现对一个非基本数据类型的对象进行复制，但不能影响到原对
	象). clone() 是 Object 的受保护方法，这意味着，如果一个类不显式去覆盖 clone() 就没有这	个方法。
	浅拷贝：拷贝实例和原始实例的引用类型引用同一个对象；
	深拷贝：拷贝实例和原始实例的引用类型引用不同对象
	使用 clone() 方法来拷贝一个对象即复杂又有风险，它会抛出异常，并且还需要类型转换。最好不要
	去使用 clone()，可以使用拷贝构造函数或者拷贝工厂来拷贝一个对象。

	
### 说出一些常用的类，包，接口，常见的runtime exception，请各举5个

常用的类

- System类：
- String类： 
- Math类：
- Thread类
- Integer类:
- Random类：

常用的包

- java.lang
- java.util
- java.io
- java.awt
- java.sql

常用接口

- List
- Map
- Comparable
- Runnable
- Remote

runtime exception

- NullPointerException
- OutOfMemoryException
- ClassCastException （类型转换异常）
- IndexOutOfBoundsException（数组越界异常)
- ArithmeticException（算术异常)

### int 和long是怎么存放在内存的?

### String 和StringBuffer的区别？
- String和StringBuffer类，它们可以储存和操作字符串。String类提供了数值不可改变的字符串，而StringBuffer类提供的字符串可以进行修改,典型地，你可以使用StringBuffers来动态构造字符数据。

- String类覆盖了equals方法和hashCode方法，而StringBuffer没有覆盖equals方法和hashCode方法。所以，将StringBuffer对象存储进Java集合类中时会出现问题。

### Arraylist和Linkedlist的区别？

### 同步 I/O （阻塞，非阻塞）异步 I/O 的理解？为什么异步 I/O 会比同步 I/O 效率高？

## 对象锁，类锁，方法锁这些有什么区别?

## Java网络编程
## java的collection和collections的区别？
## HashMap原理？hashmap的结构，是不是线程安全的?
	
# 数据库	

## 说说你常用的数据库？
    MySQL，一般用的是哪种存储引擎（Engine）？
	MySQL常用存储引擎：InnoDB 和 MyISAM，其中InnoDB适用频繁维护的，修改 插入等的数据库
	MyISAM适合少改写、少插入的读取频繁的表。开发的，肯定是InnoDB存储引擎用的多了。
	
## 事务？
什么是事务？

	事务是并发控制的单位，是用户定义的一个操作序列，要么全做，要么不做。若因为某个原因其中一条指
	令执行有误，则撤销之前执行过的所有指令，主要是为了保证数据的完整性。
	
为什么需要事务？

	为了保证数据的完整性。事务就是为了解决数据安全操作提出的，事务控制实际上就是控制数据的安全访
	问。

事务的特点？

	原子性、一致性、隔离性、持久性。
	
	（1）事务的原子性表示事务所包含的所有操作要么全部成功，要么失败回滚。如果成功那么全部应用到
	数据库，如果失败那么不能对数据库产生任何影响。
	
	（2）事务的一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事
	务执行之前和执行之后都必须处于一致性状态。
	拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，
	事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性
	
	（3）事务的隔离性是指一个事务所做的修改在最终提交以前，对其他事务是不可见的。
	
	（4）持久性是指一旦事务提交，则其所做的修改就会永久保存到数据库中。此时即使系统崩溃，修改的
	数据也不会丢失。
	
数据库的四个隔离级别？

	针对数据库的特性之隔离性，会遇到以下问题：
	（1）脏读：事务A读取了事务B未提交的数据
	（2）不可重复读： 事务A读数据库，事务B写数据库，事务A连续两次读中间B进行了一次写操作，导致A
	连续两次读去的结果不一样。
	（3）丢失更新： 事务A，B均写入数据，A写入的数据被事务B覆盖了。
	（4）幻读： 事务A修改数据库表中的数据，事务B向表中插入一条数据，事务A读取时发现有一条数据没
	有被修改，仿佛产生了幻觉。
	
	针对以上的问题，产生了四种事务的隔离级别：
	（1）Read Uncommitted(未提交读）：会读取到未提交的数据。没有解决任何问题。但这种模式也不
	是说完全没加锁，在读取时是不会加锁的，但在更新数据时，对其加行级共享锁（其它事务不能更改，但
	可以读取，导致脏读），事务结束时释放。
	（2）Read Committed（提交读）：读取的数据是已提交成功的。解决了脏读问题。解决方式是给写数
	据加行级排他锁，这样写过程是无法读取的，直到事务处理完毕才释放排他锁，给读的数据加行级共享
	锁，这样读的时候也是无法写的，但是一旦读完该行就释放共享锁。这种模式下虽然处理了脏读，但是并
	没有处理丢失更新和不可重复读的问题。
	（3）Repeatable Read(可重复读）：可以重复读取数据。解决了不可重复读和更新丢失问题。解决办
	法：给写的数据加行级排他锁，事务结束释放，给读的数据加行级共享锁，事务结束后释放。
	（4）Serializable（序列化）：事务读数据则加表级共享锁，事务写数据则加表级排他锁，幻读问题
	也得到了解决。
	
		
Java事务？

	Java事务的类型有3种，JDBC事务、JTA（Java Transaction API)事务，容器事务。
	
	平时我们一般怎么处理事务？
	Spring的事务是通过“声明式事务”的方式对事务进行管理，即在配置文件中进行声明，通过AOP将事务
	切面切入程序，最大的好处是大大减少了代码量提高了工作效率。
	

## 数据库索引的原理是什么？B树和B+树有什么区别？什么是红黑树？有哪些索引？可不可以同时在一张表设置多个索引（n个）？索引的优缺点？一张性别表和一张学号表，哪个适合建索引？为什么？

## Mysql 分页是怎么实现的？
## sql之left join、right join、inner join？
## sql优化？
## 死锁？
	索引

# Spring

## AOP的原理，什么是静态植入、动态植入？
## 解释IOC的原理
## 有哪些创建Bean的方式？
## xml配置和java配置是否可以同时存在？为什么？
## springmvc的配置，有什么好处？servlet的原理，jdbc连接数据库。
## spring事务如何实现？

# Mybatis
## mybatis的原理，如何实现？
## mybatis如何防止注入攻击?

# 网络
### TCP三次握手？
###  TCP/IP 的了解，连接 3 次握手和关闭 4 次挥手， time_wait 的作用？
### HTTP 协议是哪一层的？其报文结构如何？
	HTTP协议是应用层的。
	请求报文：请求行， 请求头部， 空行， 请求数据。
	![](https://github.com/CyC2018/Interview-Notebook/blob/master/pics/HTTP_RequestMessageExample.png)
	响应报文：状态行， 响应头部， 空行， 响应正文。
	![](https://github.com/CyC2018/Interview-Notebook/blob/master/pics/HTTP_ResponseMessageExample.png)
	
### HTTP 请求方法

### HTTP 状态码
```java
200 OK                        //客户端请求成功
400 Bad Request               //客户端请求有语法错误，不能被服务器所理解
401 Unauthorized              //请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用 
403 Forbidden                 //服务器收到请求，但是拒绝提供服务
404 Not Found                 //请求资源不存在，eg：输入了错误的URL
500 Internal Server Error     //服务器发生不可预期的错误
503 Server Unavailable        //服务器当前不能处理客户端的请求，一段时间后可能恢复正常
```
	
### HTTP 协议有哪些特点？
	（1）支持B/S 和 C/S 模式。
	（2）简单快速：客户向服务器请求服务时，只需传送请求方法和路径。
	（3）灵活：HTTP允许传送任意类型的数据对象。
	（4）无连接：HTTP限制每次连接只处理一次请求，服务器处理完请求，收到客户端的应答后就释放连
	接。
	注1: 无连接的好处是节省传输时间。因为传输具有突发性，请求时建立，请求完释放连接，可以尽快释
	放资源来服务其他客户端。
	注2: Keep-Alive 的功能使客户端到服务端的HTTP连接持续有效，客户端下次请求服务时无需再重新
	建立HTTP连接。（网页里面可能嵌了很多图片，此时如果为每个图片请求建立一个HTTP连接，效率就会
	很低）
	（5）无状态：无状态是指HTTP协议对于事务处理是没有记忆能力的。服务器不知道客户端的状态，即
	我们给服务器发送HTTP请求，服务器会处理请求，给我们发送数据过来，但是发送完，不会有任何记录
	信息。
	优点：解放了服务器，服务器“点到即止”，不会造成不必要的占用。
	缺点：每次请求会传送大量的重复数据。保持HTTP连接状态的两大技术：Cookie 和 Session。
	
### Cookie & Session

### HTTP 请求/响应的步骤？
	（1）客户端连接到 web 服务器：一个HTTP客户端通常是浏览器，与web服务器的HTTP端口（默认是
	80）建立一个TCP套接字连接。
	
	（2）客户端发送HTTP请求：通过 TCP 套接字，客户端向 web 服务器发送一个HTTP请求报文，请求
	报文。
	
	（3）服务器接受请求并返回HTTP响应：web 服务器解析请求，定位请求资源，服务器将资源副本写到
	TCP 套接字中，供客户端读取。
	
	（4）释放 TCP 连接： 若 connection 模式为 close， 则服务端主动关闭连接，客户端被动关闭
	连接，释放连接。若 connection 模式为 Keep-Alive，则连接会保持一段时间，在这段时间内，服
	务端可以继续接收请求。
	
	（5）客户端浏览器解析 HTML 内容： 客户端浏览器首先解析状态行，看是否请求成功。然后解析响应
	头部，响应头部告知以下为多少字节的HTML文档和文档的字符集。最后读取响应数据 HTML, 根据
	HTML 的语法对其进行格式化，最后显示在浏览器窗口。
	
	
### 七层网络结构是？
	物理层、链路层、网络层、传输层、会话层、表示层、应用层。

# 数据结构和算法

## 基本算法
### 动态规划
	动态规划基本要素：
	（1）最优子结构
		当一个问题的最优解包含子问题的最优解时，称这个问题具有最优子结构。
	（2）重叠子问题
		在问题的求解过程中，很多子问题的解将被多次使用。
		
	自底向上
	

### 贪心算法
	贪心算法基本要素：
	（1）最优子结构
		当一个问题的最优解包含子问题的最优解时，称这个问题具有最优子结构。
	（2）贪心选择性
		当一个问题的全局最优解可以由局部最优解得到，这个问题具有贪心选择性。
		
	自顶向下

	

## 手写代码
### 写java二分查找代码
```java

public class Main {
    // 二分查找，要求数组有序。时间复杂度为 O(logN)。

    // 非递归 二分查找
    public static int binarySearch(int[] a, int key) {
        int low = 0;
        int high = a.length - 1;
        int mid = 0;
        while (low <= high) {
            mid = (low + high) / 2;
            if (key < a[mid]) // 查找值比中值小
                high = mid - 1; // 最高下标调整到比中值小1，在原先中值的左边找
            else if (key > a[mid]) // 查找值比中值大
                low = mid + 1;
            else // 相等
                return mid; // 下标
        }
        return -1; // 以上都未返回，则没找到
    }

    // 递归 二分查找
    public static int recursionBinarySearch(int[] a, int key, int low, int high) {
        if (low <= high) {
            int mid = (low + high) / 2;
            if (key < a[mid]) // 查找值比中值小
                // 最高下标调整到比中值小1，在原先中值的左边找
                return recursionBinarySearch(a, key, low, mid - 1);
            else if (key > a[mid]) // 查找值比中值大
                // 最小下标=中值+1，在原先中值右边找
                return recursionBinarySearch(a, key, mid + 1, high);
            else // 相等
                return mid; // 下标
        }
        return -1;// 以上都未返回，则没找到
    }

    public static void main(String[] args) {
        int a[] = { 1, 2, 4, 5, 7, 9, 11, 25, 28 };
        System.out.println(binarySearch(a, 28));
        System.out.println(recursionBinarySearch(a,28,0,a.length-1));
    }
}
```
## 1.二叉树了解吗?

# 多线程

### 进程和线程之间有什么区别？

### 多线程编程的好处是什么？
	多线程可以实现任务的并发执行，从而提高效率。CPU 不会因为某个线程等待资源而处于空闲状态。多
	个线程共享进程的堆内存，创建多个线程要比创建多个进程方便。
	
### 用户线程和守护线程？
	当我们在java程序中创建一个线程的时候，它默认就是用户线程。
	
	任何一个守护线程是在后台运行的线程，它是所有用户线程的保姆，它为其他线程的运行提供便利服
	务，最典型的就是GC(垃圾回收器）。
	守护线程不会阻止 java 虚拟机的终止，当没有用户线程运行的时候，jvm 虚拟机关闭程序并且退
	出。
	
	thread.setDamon(true)设置为守护线程。
	
### 你一般如何实现多线程？
	java提供了两种方式，一个是继承Thread类，另一个是实现Runnable接口，由于java不支持多继
	承，所以在多继承的时候，我们优先选用实现 Runnable接口，因为我们可以通过实现接口的办法，间
	接的实现多继承。
	
### 有哪些不同的线程生命周期？
	（1）NEW: 新创建了一个线程对象。
	
	（2）RuUNNABLE: 调用了线程的 start 方法，线程进入 RUNNABLE 线程池，线程为就绪状态。
	
	（3）RUNNING: 线程调度器为 RUNNABLE 线程池中的线程分配 CPU 时间，线程进入 RUNNING 状
	态。
	
	（4）BLOCKING: 线程因为某种原因放弃了 CPU 使用权，暂时停止运行，进入阻塞状态。阻塞的情况
	主要有3种：
	等待阻塞：运行(running)的线程执行wait() 方法，JVM 会把该线程放入等待队列中。
	同步阻塞：运行(running)的线程在获取对象的同步锁时，如果该所被其他线程占用，那么 JVM 会将
	该线程放入锁池。
	其他阻塞：运行(running)的线程执行Thread.sleep(long ms)或t.join()方法，或者发出了I/O
	请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者
	I/O 处理完毕时，线程重新转入可运行(runnable)状态。
	
	(5) DEAD: 线程 run() mian()方法执行结束，或因异常退出了 run(), 线程的生命周期结束。死
	亡的线程不可再次复生。

### start() 和 run() 方法有什么区别？
	start() 方法是创建一个新的线程来执行 run 方法，实现多线程。调用start 方法后，创建了一个
	新的线程进入 RUNNABLE 线程池，为就绪状态。调用者线程可以和这个线程并行运行。
	
	run() 方法的行为就会和普通的方法一样，只有等 run 方法运行结束后，才可以接着执行调用下面
	的代码。	
	
### 你对线程优先级的理解是什么？
	每一个线程都有一个优先级，线程优先级是一个 int 变量，从 1 到 10，1 表示最低优先级，10 表
	示最高优先级。一般来说，高优先级的线程在运行时具有优先权，但这依赖于线程调度的实现，这个实
	现与操作系统有关。我们可以定义线程的优先级，但是这并不能保证高优先级的线程在低优先级线程之
	前实现。
	
	线程调度并不受 JVM 控制，所以最好由应用程序来控制它。所以尽量不要让程序依赖于线程的优先级
	
### 你如何确保 mian() 方法所在的线程是 java 程序最后结束的进程？ 
	我们可以使用 Thread 类的 join() 方法确保所有程序创建的线程在 main() 方法退出之前结束。
	
	方法 join() 的作用是等待线程对象销毁。当前线程等待某个线程销毁后再接着执行后面的代码。在 
	join 过程中，如果当前线程对象被中断 interrupt(), 则当前线程抛出异常。
	join 在内部使用wait() 进行等待。
	
### 线程之间是通过哪些方法进行通信？
	只能在同步方法或同步代码块中使用。
- wait()： 使当前执行代码的线程进行等待，将当前线程放到“预执行队列”中，并且在wait()所在的代码处停止执行

- notify()： 用来通知那些等待该对象的对象锁的其他线程中的一个。在执行该方法后，当前线程不会马上释放该对象锁，呈wait状态的对象锁也不能立即获得该锁。

- notifyAll()

### 为什么wait(), notify()和notifyAll()必须在同步方法或者同步块中被调用？
	在 java 中，所有对象都能被作为“监视器（monitor）", 监视器指一个拥有一个独占锁，一个入口
	队列，一个等待队列的 entity. 所有对象的非同步方法可以在在任意时刻被任意线程调用，此时不需
	要考虑加锁问题。而对于对象的同步方法来说，在任意时刻有且仅有一个拥有该对象独占锁的线程的线程
	能够调用它们。
	
	wait() 方法强制当前线程释放对象锁，这意味着在调用 某对象的 wait() 方法之前必须已经获得该
	对象的锁。因此，线程必须在某个对象的同步方法或同步代码块中使用 wait() 方法。
	当一个线程正在某一个对象的同步方法中运行时调用了这个对象的 wait() 方法，那么这个线程将被释
	放该对象的独占锁并放入这个对象的等待队列中。
	
	当某线程调用某对象的 notify() / notifyAll() 方法时，任意一个 / 所有 在该对象的等待队列
	中的线程将被转移到该对象的入口队列。接着这些线程将竞争该对象的锁。这意味着，在调用对象的 
	notify() 和 notifyAll() 之前，调用线程必须已经得到该对象的锁。因此，必须在某个对象的同
	步方法或同步代码块中才能调用该对象的notify()或notifyAll()方法。

### 多线程的运行机制，怎么加锁的?

### 线程池怎么实现的，线程池中的coreNum和maxNum有什么不同？

### One loop per thread + threadpool 的理解？ One loop 的 loop 指什么？



# RESTful
### restful api了解不，说说get，put，post，delete的区别？

### post有什么好处，处理json字符串的jar包是什么？




# 项目
## 详细讨论一两个你的项目中的技术细节

# 其他
### 你认为你编程最大的挑战是什么?

# 实习
## 实习主要做了哪些事情？

	
	


