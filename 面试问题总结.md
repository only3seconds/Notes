# Java 基础


## 说出Object类的常用方法？
	1.public final native Class<?> getClass()
	getClass方法用于获得一个对象的类型类
	
	2.public String toString()
	默认返回 ToStringExample@4554617c 这种形式，其中 @ 后面的数值为散列码的无符号十六进制
	表示。
	
	3.public boolean equals(Object obj)
	equals 与 == 的区别
	对于==方法，如果作用于基本数据类型的变量，则直接比较其存储的 “值”是否相等；如果作用于引用
	类型的变量，则比较的是所指向的对象的地址是否相同，即是否指向同一个对象；
	对于equals方法，注意：equals方法不能作用于基本数据类型的变量。如果没有对equals方法进行重
	写，则比较的是引用类型的变量所指向的对象的地址是否相同；诸如String、Date等类对equals方法
	进行了重写的话，比较的是所指向的对象的内容是否相同。
		
	4.public native int hashCode()
	(1) hasCode() 返回散列值，而 equals() 是用来判断两个实例是否等价。等价的两个实例散列值
	定要相同，但是散列值相同的两个实例不一定等价。
	(2) 在覆盖 equals() 方法时应当总是覆盖 hashCode() 方法，保证等价的两个实例散列值也相等
	
	5.void wait()
	使当前执行代码的线程进行等待，直到接到通知或者被中断。
	wait()释放锁
		
	6.void notify()
	唤醒在此对象监视器上等待的单个线程。 
	notify()不释放锁  
	
	7.void notifyAll()
	唤醒在此对象监视器上等待的所有线程。
	
	8.protected Object clone()
	创建并返回此对象的一个副本。（可以实现对一个非基本数据类型的对象进行复制，但不能影响到原对
	象). clone() 是 Object 的受保护方法，这意味着，如果一个类不显式去覆盖 clone() 就没有这	个方法。
	浅拷贝：拷贝实例和原始实例的引用类型引用同一个对象；
	深拷贝：拷贝实例和原始实例的引用类型引用不同对象
	使用 clone() 方法来拷贝一个对象即复杂又有风险，它会抛出异常，并且还需要类型转换。最好不要
	去使用 clone()，可以使用拷贝构造函数或者拷贝工厂来拷贝一个对象。

	
## 说出一些常用的类，包，接口，常见的runtime exception，请各举5个

### 常用的类
- System类：
- String类： 
- Math类：
- Integer类:
- Random类：

### 常用的包
- java.lang
- java.util
- java.io
- java.awt
- java.sql

### 常用接口
- List
- Map
- Comparable
- Runnable
- Remote

### runtime exception
- NullPointerException
- OutOfMemoryException
- ClassCastException （类型转换异常）
- IndexOutOfBoundsException（数组越界异常)
- .ArithmeticException（算术异常)

## String 和StringBuffer的区别？
- String和StringBuffer类，它们可以储存和操作字符串。String类提供了数值不可改变的字符串，而StringBuffer类提供的字符串可以进行修改,典型地，你可以使用StringBuffers来动态构造字符数据。

- String类覆盖了equals方法和hashCode方法，而StringBuffer没有覆盖equals方法和hashCode方法。所以，将StringBuffer对象存储进Java集合类中时会出现问题。

## 多线程的一些问题？
### 你一般如何实现多线程？
	java提供了两种方式，一个是继承Thread类，另一个是实现Runnable接口，由于java不支持多继承，
	所以在多继承的时候，我们优先选用 实现 Runnable接口，因为我们可以通过实现接口的办法，间接的
	实现多继承。
	
### 线程之间是通过哪些方法进行通信？
	只能在同步方法或同步代码块中使用。
- wait()： 使当前执行代码的线程进行等待，将当前线程放到“预执行队列”中，并且在wait()所在的代码处停止执行

- notify()： 用来通知那些等待该对象的对象锁的其他线程中的一个。在执行该方法后，当前线程不会马上释放该对象锁，呈wait状态的对象锁也不能立即获得该锁。

- notifyAll()

### 线程池
	
# 数据库	

## 说说你常用的数据库？
### MySQL，一般用的是哪种存储引擎（Engine）？
	MySQL常用存储引擎：InnoDB 和 MyISAM，其中InnoDB适用频繁维护的，修改 插入等的数据库
	MyISAM适合少改写、少插入的读取频繁的表。开发的，肯定是InnoDB存储引擎用的多了。
	
### 事务？
什么是事务？

	事务是并发控制的单位，是用户定义的一个操作序列，要么全做，要么不做。若因为某个原因其中一条指
	令执行有误，则撤销之前执行过的所有指令，主要是为了保证数据的完整性。
	
为什么需要事务？

	为了保证数据的完整性。事务就是为了解决数据安全操作提出的，事务控制实际上就是控制数据的安全访
	问。

事务的特点？

	原子性、一致性、隔离性、持久性。
	
	（1）事务的原子性表示事务所包含的所有操作要么全部成功，要么失败回滚。如果成功那么全部应用到
	数据库，如果失败那么不能对数据库产生任何影响。
	
	（2）事务的一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事
	务执行之前和执行之后都必须处于一致性状态。
	拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，
	事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性
	
	（3）事务的隔离性是指一个事务所做的修改在最终提交以前，对其他事务是不可见的。
	
	（4）持久性是指一旦事务提交，则其所做的修改就会永久保存到数据库中。此时即使系统崩溃，修改的
	数据也不会丢失。
	
数据库的四个隔离级别？

	针对数据库的特性之隔离性，会遇到以下问题：
	（1）脏读：事务A读取了事务B未提交的数据
	（2）不可重复读： 事务A读数据库，事务B写数据库，事务A连续两次读中间B进行了一次写操作，导致A
	连续两次读去的结果不一样。
	（3）丢失更新： 事务A，B均写入数据，A写入的数据被事务B覆盖了。
	（4）幻读： 事务A修改数据库表中的数据，事务B向表中插入一条数据，事务A读取时发现有一条数据没
	有被修改，仿佛产生了幻觉。
	
	针对以上的问题，产生了四种事务的隔离级别：
	（1）Read Uncommitted(未提交读）：会读取到未提交的数据。没有解决任何问题。但这种模式也不
	是说完全没加锁，在读取时是不会加锁的，但在更新数据时，对其加行级共享锁（其它事务不能更改，但
	可以读取，导致脏读），事务结束时释放。
	（2）Read Committed（提交读）：读取的数据是已提交成功的。解决了脏读问题。解决方式是给写数
	据加行级排他锁，这样写过程是无法读取的，直到事务处理完毕才释放排他锁，给读的数据加行级共享
	锁，这样读的时候也是无法写的，但是一旦读完该行就释放共享锁。这种模式下虽然处理了脏读，但是并
	没有处理丢失更新和不可重复读的问题。
	（3）Repeatable Read(可重复读）：可以重复读取数据。解决了不可重复读和更新丢失问题。解决办
	法：给写的数据加行级排他锁，事务结束释放，给读的数据加行级共享锁，事务结束后释放。
	（4）Serializable（序列化）：事务读数据则加表级共享锁，事务写数据则加表级排他锁，幻读问题
	也得到了解决。
	
		
Java事务？
	Java事务的类型有3种，JDBC事务、JTA（Java Transaction API)事务，容器事务。
	
	平时我们一般怎么处理事务？
	Spring的事务是通过“声明式事务”的方式对事务进行管理，即在配置文件中进行声明，通过AOP将事务
	切面切入程序，最大的好处是大大减少了代码量提高了工作效率。
	

### 数据库索引
### Mysql 分页是怎么实现的？

	
	


