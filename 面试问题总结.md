# Java 基础


### 面向对象和基于对象的区别？

### Java 反射？
	JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对
	象，都能够调用它的任意一个方法和属性；这种动态获取信息以及动态调用对象的方法的功能称为java
	语言的反射机制。

### 反射机制的一般步骤？
	第一：获取类加载器：ClassLoader 		loader=Thread.currentThread().getContextClassLoader();//获取当前线程的上下文类加载器

	第二：通过类加载器获取类  Class clazz=loader.loadClass("com.taobao.reflect.car")//通过对象的全称限定来获取对象。

	第三：通过clazz获得构造函数：Constructors cons=clazz.getDeclaraedConstructors(Class[]null);//调用默认的构造函数

	第四：然后通过构造函数构造对象：Car car=(Car)cons.newInstance();//获取类的默认构造函数对象并实例化对象。

	第五：得到car对象，然后调用car的方法：Method methd =car.getMethod("setName","String.class");//method声明，并指向car的setName这个方法，得到setName方法。


	
	
![](https://blog.csdn.net/sinat_38259539/article/details/71799078)

### 说出Object类的常用方法？
	1.public final native Class<?> getClass()
	getClass方法用于获得一个对象的类型类
	
	2.public String toString()
	默认返回 ToStringExample@4554617c 这种形式，其中 @ 后面的数值为散列码的无符号十六进制
	表示。
	
	3.public boolean equals(Object obj)
	equals 与 == 的区别
	对于==方法，如果作用于基本数据类型的变量，则直接比较其存储的 “值”是否相等；如果作用于引用
	类型的变量，则比较的是所指向的对象的地址是否相同，即是否指向同一个对象；
	对于equals方法，注意：equals方法不能作用于基本数据类型的变量。如果没有对equals方法进行重
	写，则比较的是引用类型的变量所指向的对象的地址是否相同；诸如String、Date等类对equals方法
	进行了重写的话，比较的是所指向的对象的内容是否相同。
		
	4.public native int hashCode()
	(1) hasCode() 返回散列值，而 equals() 是用来判断两个实例是否等价。等价的两个实例散列值
	定要相同，但是散列值相同的两个实例不一定等价。
	(2) 在覆盖 equals() 方法时应当总是覆盖 hashCode() 方法，保证等价的两个实例散列值也相等
	
	5.void wait()
	使当前执行代码的线程进行等待，直到接到通知或者被中断。每个锁对象都有两个队列，分别是就绪队列
	和阻塞队列，一个线程被 wait 后就会进入阻塞队列。
	wait()方法执行后立即释放锁。
	wait(long) 等待某一时间内是否有线程对锁进行唤醒，如果超过这个时间则自动唤醒。
		
	6.void notify()
	随机唤醒在此对象监视器上等待的单个线程。 
	当方法notify()被执行后，锁不自动释放，必须执行完notify（）所在的synchronized代码块后才
	释放锁
	
	7.void notifyAll()
	唤醒在此对象监视器上等待的所有线程。
	
	8.protected Object clone()
	创建并返回此对象的一个副本。（可以实现对一个非基本数据类型的对象进行复制，但不能影响到原对
	象). clone() 是 Object 的受保护方法，这意味着，如果一个类不显式去覆盖 clone() 就没有这	个方法。
	浅拷贝：拷贝实例和原始实例的引用类型引用同一个对象；
	深拷贝：拷贝实例和原始实例的引用类型引用不同对象
	使用 clone() 方法来拷贝一个对象即复杂又有风险，它会抛出异常，并且还需要类型转换。最好不要
	去使用 clone()，可以使用拷贝构造函数或者拷贝工厂来拷贝一个对象。

	
### 说出一些常用的类，包，接口，常见的runtime exception，请各举5个

常用的类

- System类：
- String类： 
- Math类：
- Thread类
- Integer类:
- Random类：

常用的包

- java.lang
- java.util
- java.io
- java.awt
- java.sql

常用接口

- List
- Map
- Comparable
- Runnable
- Remote

runtime exception

- NullPointerException
- OutOfMemoryException
- ClassCastException （类型转换异常）
- IndexOutOfBoundsException（数组越界异常)
- ArithmeticException（算术异常)

### int 和long是怎么存放在内存的?

### String 和StringBuffer的区别？
- String和StringBuffer类，它们可以储存和操作字符串。String类提供了数值不可改变的字符串，而StringBuffer类提供的字符串可以进行修改,典型地，你可以使用StringBuffers来动态构造字符数据。

- String类覆盖了equals方法和hashCode方法，而StringBuffer没有覆盖equals方法和hashCode方法。所以，将StringBuffer对象存储进Java集合类中时会出现问题。

### Arraylist和Linkedlist的区别？

### 同步 I/O （阻塞，非阻塞）异步 I/O 的理解？为什么异步 I/O 会比同步 I/O 效率高？

## 对象锁，类锁，方法锁这些有什么区别?

## Java网络编程
## java的collection和collections的区别？
## HashMap原理？hashmap的结构，是不是线程安全的?
	
# 数据库	

### 说说你常用的数据库？
	MySQL，一般用的是哪种存储引擎（Engine）？
	MySQL常用存储引擎：InnoDB 和 MyISAM，其中InnoDB适用频繁维护的，修改插入等的数据库
	MyISAM适合少改写、少插入的读取频繁的表。开发的，肯定是InnoDB存储引擎用的多了。
	
## 事务？
什么是事务？

	事务是并发控制的单位，是用户定义的一个操作序列，要么全做，要么不做。若因为某个原因其中一条指
	令执行有误，则撤销之前执行过的所有指令，主要是为了保证数据的完整性。
	
为什么需要事务？

	为了保证数据的完整性。事务就是为了解决数据安全操作提出的，事务控制实际上就是控制数据的安全访
	问。

事务的特点？

	原子性、一致性、隔离性、持久性。
	
	（1）事务的原子性表示事务所包含的所有操作要么全部成功，要么失败回滚。如果成功那么全部应用到
	数据库，如果失败那么不能对数据库产生任何影响。
	
	（2）事务的一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事
	务执行之前和执行之后都必须处于一致性状态。
	拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，
	事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性
	
	（3）事务的隔离性是指一个事务所做的修改在最终提交以前，对其他事务是不可见的。
	
	（4）持久性是指一旦事务提交，则其所做的修改就会永久保存到数据库中。此时即使系统崩溃，修改的
	数据也不会丢失。
	
数据库的四个隔离级别？

	针对数据库的特性之隔离性，会遇到以下问题：
	（1）脏读：事务A读取了事务B未提交的数据
	（2）不可重复读： 事务A读数据库，事务B写数据库，事务A连续两次读中间B进行了一次写操作，导致A
	连续两次读去的结果不一样。
	（3）丢失更新： 事务A，B均写入数据，A写入的数据被事务B覆盖了。
	（4）幻读： 事务A修改数据库表中的数据，事务B向表中插入一条数据，事务A读取时发现有一条数据没
	有被修改，仿佛产生了幻觉。
	
	针对以上的问题，产生了四种事务的隔离级别：
	（1）Read Uncommitted(未提交读）：会读取到未提交的数据。没有解决任何问题。但这种模式也不
	是说完全没加锁，在读取时是不会加锁的，但在更新数据时，对其加行级共享锁（其它事务不能更改，但
	可以读取，导致脏读），事务结束时释放。
	（2）Read Committed（提交读）：读取的数据是已提交成功的。解决了脏读问题。解决方式是给写数
	据加行级排他锁，这样写过程是无法读取的，直到事务处理完毕才释放排他锁，给读的数据加行级共享
	锁，这样读的时候也是无法写的，但是一旦读完该行就释放共享锁。这种模式下虽然处理了脏读，但是并
	没有处理丢失更新和不可重复读的问题。
	（3）Repeatable Read(可重复读）：可以重复读取数据。解决了不可重复读和更新丢失问题。解决办
	法：给写的数据加行级排他锁，事务结束释放，给读的数据加行级共享锁，事务结束后释放。
	（4）Serializable（序列化）：事务读数据则加表级共享锁，事务写数据则加表级排他锁，幻读问题
	也得到了解决。
	
		
Java事务？

	Java事务的类型有3种，JDBC事务、JTA（Java Transaction API)事务，容器事务。
	
	平时我们一般怎么处理事务？
	Spring的事务是通过“声明式事务”的方式对事务进行管理，即在配置文件中进行声明，通过AOP将事务
	切面切入程序，最大的好处是大大减少了代码量提高了工作效率。
	

## 数据库索引的原理是什么？B树和B+树有什么区别？什么是红黑树？有哪些索引？可不可以同时在一张表设置多个索引（n个）？索引的优缺点？一张性别表和一张学号表，哪个适合建索引？为什么？

## Mysql 分页是怎么实现的？
## sql之left join、right join、inner join？
## sql优化？
## 死锁？
	索引

# Spring

## AOP的原理，什么是静态植入、动态植入？
## 解释IOC的原理
## 有哪些创建Bean的方式？
## xml配置和java配置是否可以同时存在？为什么？
## springmvc的配置，有什么好处？servlet的原理，jdbc连接数据库。
## spring事务如何实现？

# Mybatis
## mybatis的原理，如何实现？
## mybatis如何防止注入攻击?

# 网络
### TCP三次握手？
###  TCP/IP 的了解，连接 3 次握手和关闭 4 次挥手， time_wait 的作用？
### HTTP 协议是哪一层的？其报文结构如何？
	HTTP协议是应用层的。
	请求报文：请求行， 请求头部， 空行， 请求数据。
	![](https://github.com/CyC2018/Interview-Notebook/blob/master/pics/HTTP_RequestMessageExample.png)
	响应报文：状态行， 响应头部， 空行， 响应正文。
	![](https://github.com/CyC2018/Interview-Notebook/blob/master/pics/HTTP_ResponseMessageExample.png)
	
### HTTP 请求方法

### HTTP 状态码
```java
200 OK                        //客户端请求成功
400 Bad Request               //客户端请求有语法错误，不能被服务器所理解
401 Unauthorized              //请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用 
403 Forbidden                 //服务器收到请求，但是拒绝提供服务
404 Not Found                 //请求资源不存在，eg：输入了错误的URL
500 Internal Server Error     //服务器发生不可预期的错误
503 Server Unavailable        //服务器当前不能处理客户端的请求，一段时间后可能恢复正常
```
	
### HTTP 协议有哪些特点？
	（1）支持B/S 和 C/S 模式。
	（2）简单快速：客户向服务器请求服务时，只需传送请求方法和路径。
	（3）灵活：HTTP允许传送任意类型的数据对象。
	（4）无连接：HTTP限制每次连接只处理一次请求，服务器处理完请求，收到客户端的应答后就释放连
	接。
	注1: 无连接的好处是节省传输时间。因为传输具有突发性，请求时建立，请求完释放连接，可以尽快释
	放资源来服务其他客户端。
	注2: Keep-Alive 的功能使客户端到服务端的HTTP连接持续有效，客户端下次请求服务时无需再重新
	建立HTTP连接。（网页里面可能嵌了很多图片，此时如果为每个图片请求建立一个HTTP连接，效率就会
	很低）
	（5）无状态：无状态是指HTTP协议对于事务处理是没有记忆能力的。服务器不知道客户端的状态，即
	我们给服务器发送HTTP请求，服务器会处理请求，给我们发送数据过来，但是发送完，不会有任何记录
	信息。
	优点：解放了服务器，服务器“点到即止”，不会造成不必要的占用。
	缺点：每次请求会传送大量的重复数据。保持HTTP连接状态的两大技术：Cookie 和 Session。
	
### Cookie & Session

### HTTP 请求/响应的步骤？
	（1）客户端连接到 web 服务器：一个HTTP客户端通常是浏览器，与web服务器的HTTP端口（默认是
	80）建立一个TCP套接字连接。
	
	（2）客户端发送HTTP请求：通过 TCP 套接字，客户端向 web 服务器发送一个HTTP请求报文，请求
	报文。
	
	（3）服务器接受请求并返回HTTP响应：web 服务器解析请求，定位请求资源，服务器将资源副本写到
	TCP 套接字中，供客户端读取。
	
	（4）释放 TCP 连接： 若 connection 模式为 close， 则服务端主动关闭连接，客户端被动关闭
	连接，释放连接。若 connection 模式为 Keep-Alive，则连接会保持一段时间，在这段时间内，服
	务端可以继续接收请求。
	
	（5）客户端浏览器解析 HTML 内容： 客户端浏览器首先解析状态行，看是否请求成功。然后解析响应
	头部，响应头部告知以下为多少字节的HTML文档和文档的字符集。最后读取响应数据 HTML, 根据
	HTML 的语法对其进行格式化，最后显示在浏览器窗口。
	
	
### 七层网络结构是？
	物理层、链路层、网络层、传输层、会话层、表示层、应用层。

# 数据结构和算法

## 基本算法
### 动态规划
	动态规划基本要素：
	（1）最优子结构
		当一个问题的最优解包含子问题的最优解时，称这个问题具有最优子结构。
	（2）重叠子问题
		在问题的求解过程中，很多子问题的解将被多次使用。
		
	自底向上
	

### 贪心算法
	贪心算法基本要素：
	（1）最优子结构
		当一个问题的最优解包含子问题的最优解时，称这个问题具有最优子结构。
	（2）贪心选择性
		当一个问题的全局最优解可以由局部最优解得到，这个问题具有贪心选择性。
		
	自顶向下

	

## 手写代码
### 写java二分查找代码
```java

public class Main {
    // 二分查找，要求数组有序。时间复杂度为 O(logN)。

    // 非递归 二分查找
    public static int binarySearch(int[] a, int key) {
        int low = 0;
        int high = a.length - 1;
        int mid = 0;
        while (low <= high) {
            mid = (low + high) / 2;
            if (key < a[mid]) // 查找值比中值小
                high = mid - 1; // 最高下标调整到比中值小1，在原先中值的左边找
            else if (key > a[mid]) // 查找值比中值大
                low = mid + 1;
            else // 相等
                return mid; // 下标
        }
        return -1; // 以上都未返回，则没找到
    }

    // 递归 二分查找
    public static int recursionBinarySearch(int[] a, int key, int low, int high) {
        if (low <= high) {
            int mid = (low + high) / 2;
            if (key < a[mid]) // 查找值比中值小
                // 最高下标调整到比中值小1，在原先中值的左边找
                return recursionBinarySearch(a, key, low, mid - 1);
            else if (key > a[mid]) // 查找值比中值大
                // 最小下标=中值+1，在原先中值右边找
                return recursionBinarySearch(a, key, mid + 1, high);
            else // 相等
                return mid; // 下标
        }
        return -1;// 以上都未返回，则没找到
    }

    public static void main(String[] args) {
        int a[] = { 1, 2, 4, 5, 7, 9, 11, 25, 28 };
        System.out.println(binarySearch(a, 28));
        System.out.println(recursionBinarySearch(a,28,0,a.length-1));
    }
}
```
## 1.二叉树了解吗?


# 多线程

### 进程和线程之间有什么区别？

### 多线程编程的好处是什么？
	多线程可以实现任务的并发执行，从而提高效率。CPU 不会因为某个线程等待资源而处于空闲状态。多
	个线程共享进程的堆内存，创建多个线程要比创建多个进程方便。
	
### 用户线程和守护线程？
	当我们在java程序中创建一个线程的时候，它默认就是用户线程。
	
	任何一个守护线程是在后台运行的线程，它是所有用户线程的保姆，它为其他线程的运行提供便利服
	务，最典型的就是GC(垃圾回收器）。
	守护线程不会阻止 java 虚拟机的终止，当没有用户线程运行的时候，jvm 虚拟机关闭程序并且退
	出。
	
	thread.setDamon(true)设置为守护线程。
	
### 你一般如何实现多线程？
	java提供了两种方式，一个是继承Thread类，另一个是实现Runnable接口，由于java不支持多继
	承，所以在多继承的时候，我们优先选用实现 Runnable接口，因为我们可以通过实现接口的办法，间
	接的实现多继承。
	
### 有哪些不同的线程生命周期？
	（1）NEW: 新创建了一个线程对象。
	
	（2）RuUNNABLE: 调用了线程的 start 方法，线程进入 RUNNABLE 线程池，线程为就绪状态。
	
	（3）RUNNING: 线程调度器为 RUNNABLE 线程池中的线程分配 CPU 时间，线程进入 RUNNING 状
	态。
	
	（4）BLOCKING: 线程因为某种原因放弃了 CPU 使用权，暂时停止运行，进入阻塞状态。阻塞的情况
	主要有3种：
	等待阻塞：运行(running)的线程执行wait() 方法，JVM 会把该线程放入等待队列中。
	同步阻塞：运行(running)的线程在获取对象的同步锁时，如果该所被其他线程占用，那么 JVM 会将
	该线程放入锁池。
	其他阻塞：运行(running)的线程执行Thread.sleep(long ms)或t.join()方法，或者发出了I/O
	请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者
	I/O 处理完毕时，线程重新转入可运行(runnable)状态。
	
	(5) DEAD: 线程 run() mian()方法执行结束，或因异常退出了 run(), 线程的生命周期结束。死
	亡的线程不可再次复生。

### start() 和 run() 方法有什么区别？
	start() 方法是创建一个新的线程来执行 run 方法，实现多线程。调用start 方法后，创建了一个
	新的线程进入 RUNNABLE 线程池，为就绪状态。调用者线程可以和这个线程并行运行。
	
	run() 方法的行为就会和普通的方法一样，只有等 run 方法运行结束后，才可以接着执行调用下面
	的代码。	
	
### 如何终止一个线程？
	（1）使用退出标志，使线程正常退出，也就是当run方法完成后线程终止。 
    (2) 使用stop方法强行终止线程（这个方法不推荐使用，因为stop和suspend、resume一样，也可能
    发生不可预料的结果）。 
    (3) 使用interrupt方法中断线程。
	
### 你对线程优先级的理解是什么？
	每一个线程都有一个优先级，线程优先级是一个 int 变量，从 1 到 10，1 表示最低优先级，10 表
	示最高优先级。一般来说，高优先级的线程在运行时具有优先权，但这依赖于线程调度的实现，这个实
	现与操作系统有关。我们可以定义线程的优先级，但是这并不能保证高优先级的线程在低优先级线程之
	前实现。
	
	线程调度并不受 JVM 控制，所以最好由应用程序来控制它。所以尽量不要让程序依赖于线程的优先级
	
### 你如何确保 main() 方法所在的线程是 java 程序最后结束的进程？ 
	我们可以使用 Thread 类的 join() 方法确保所有程序创建的线程在 main() 方法退出之前结束。
	
	方法 join() 的作用是等待线程对象销毁。当前线程等待某个线程销毁后再接着执行后面的代码。在 
	join 过程中，如果当前线程对象被中断 interrupt(), 则当前线程抛出异常。
	join 在内部使用wait() 进行等待。
	
### 线程之间是通过哪些方法进行通信？
	只能在同步方法或同步代码块中使用。
- wait()： 使当前执行代码的线程进行等待，将当前线程放到“预执行队列”中，并且在wait()所在的代码处停止执行

- notify()： 用来通知那些等待该对象的对象锁的其他线程中的一个。在执行该方法后，当前线程不会马上释放该对象锁，呈wait状态的对象锁也不能立即获得该锁。

- notifyAll()

### 为什么wait(), notify()和notifyAll()必须在同步方法或者同步块中被调用？
	在 java 中，所有对象都能被作为“监视器（monitor）", 监视器指一个拥有一个独占锁，一个入口
	队列，一个等待队列的 entity. 所有对象的非同步方法可以在在任意时刻被任意线程调用，此时不需
	要考虑加锁问题。而对于对象的同步方法来说，在任意时刻有且仅有一个拥有该对象独占锁的线程的线程
	能够调用它们。
	
	wait() 方法强制当前线程释放对象锁，这意味着在调用 某对象的 wait() 方法之前必须已经获得该
	对象的锁。因此，线程必须在某个对象的同步方法或同步代码块中使用 wait() 方法。
	当一个线程正在某一个对象的同步方法中运行时调用了这个对象的 wait() 方法，那么这个线程将被释
	放该对象的独占锁并放入这个对象的等待队列中。
	
	当某线程调用某对象的 notify() / notifyAll() 方法时，任意一个 / 所有 在该对象的等待队列
	中的线程将被转移到该对象的入口队列。接着这些线程将竞争该对象的锁。这意味着，在调用对象的 
	notify() 和 notifyAll() 之前，调用线程必须已经得到该对象的锁。因此，必须在某个对象的同
	步方法或同步代码块中才能调用该对象的notify()或notifyAll()方法。

### 为什么 Thread 的 sleep() 和 yield() 方法是静态的。
	Thread 类的 sleep() 和 yield() 方法将在正在执行的线程上运行。。所以在其他处于等待状态的
	线程上调用这些方法是没有意义的。这就是为什么这些方法是静态的。它们可以在当前正在执行的线程中
	工作，避免程序员错误的认为可以在其他非运行线程调用这些方法。
	
	yield()方法的作用是放弃当前的cpu资源，将它让给其他任务去占用cpu执行时间，但放弃的时间不确
	定。理论上，yield意味着放手，放弃，投降。一个调用yield()方法的线程告诉 JVM 它乐意让其他
	线程占用自己的位置。这表明该线程没有在做一些紧急的事情。注意，这仅是一个暗示，并不能保证不会
	产生任何影响。
	
### 什么是线程安全？线程安全的级别？ 
	线程安全就是多线程访问时，采用了加锁机制。当一个线程访问该类的某个共享数据时，进行保护，其他
	线程必须等该线程访问结束后才能进行访问。线程不安全就是不提供数据访问保护。
	如果你的代码在多线程下执行和在单线程下执行永远都能获得一样的结果，那么你的代码就是线程安全
	的。
	
	线程安全的级别：
	（1）不可变
	像String、Integer、Long这些，都是final类型的类，任何一个线程都改变不了它们的值，要改变
	除非新创建一个，因此这些不可变对象不需要任何同步手段就可以直接在多线程环境下使用
	
	（2）绝对线程安全
	不管运行时环境如何，调用者都不需要额外的同步措施。要做到这一点通常需要付出许多额外的代价，
	Java中标注自己是线程安全的类，实际上绝大多数都不是线程安全的，不过绝对线程安全的类，Java中
	也有，比方说CopyOnWriteArrayList、CopyOnWriteArraySet
	
	（3）相对线程安全
	相对线程安全也就是我们通常意义上所说的线程安全，像Vector这种，add、remove方法都是原子操
	作，不会被打断，但也仅限于此，如果有个线程在遍历某个Vector、有个线程同时在add这个Vector，
	99%的情况下都会出现ConcurrentModificationException，也就是fail-fast机制。
	
	（4）线程非安全
	ArrayList、LinkedList、HashMap等都是线程非安全的类
	
### 如何保证线程安全？
	在Java中可以有很多方法来保证线程安全——同步，使用原子类(atomic concurrent classes)，实
	现并发锁，使用volatile关键字，使用不变类和线程安全类。

### volatile 关键字在 java 中有什么作用？
	volatile 的作用是强制从公共堆栈中取得变量的值，而不是从线程私有数据栈中取得变量的值。多线
	程读取共享变量时可以获取最新值.
	对于 volatile 修饰的变量， JVM只是保证从主存加载到线程工作内存的值是最新的; 访问
	volatile变量并不会执行加锁操作，因此不会使执行线程阻塞; volatile 变量解决的是变量在多个
	线程之间的可见性。
	
### 什么是 ThreadLocal 类?
	类 ThreadLocal 解决的是变量在不同线程间的隔离性，也就是不同线程拥有自己的 ThreadLocal 
	变量，不同线程中的值是可以放入 ThreadLocal 类中进行保存的。
	
### 什么是 java 线程转储（Thread Dump),如何得到它？
	Thread Dump 是一个 JVM 活动线程的列表，它对于分析系统瓶颈和死锁非常有用。
	
	有很多方法可以获取线程转储：
	（1）Profiler
	（2）kill -3 命令
	（3）jstack 工具（jdk 自带的）
	
### 什么是死锁（Deadlock)？如何分析和避免死锁？
	死锁是指两个以上的线程相互等待对方的锁，而使程序无限死循环下去。
	
	分析死锁：查看线程转储，找到状态为 BLOCKED 的线程和它们所等待的资源，每个资源都有一个唯一的 id, 通过这个 id 我们可以找到哪些线程已经持有它的对象锁。
	
	避免死锁：避免嵌套锁，只在需要的地方使用锁，避免无限等待。
	
### 什么是Java Timer类？如何创建一个有特定时间间隔的任务？
	java.util.Timer 是一个工具类，可以用于安排一个线程在未来的某个特定时间执行。Timer类可以
	用安排一次性任务或者周期任务。

	java.util.TimerTask 是一个实现了Runnable接口的抽象类，我们需要去继承这个类来创建我们自
	己的定时任务并使用Timer去安排它的执行。
	
### 为什么要用线程池？
	避免频繁地创建和销毁线程，可以复用线程对象。而且，使用线程池可以根据项目灵活的改变并发线程的
	数目。
	
### 什么是线程池？如何创建一个 Java 线程池？
	一个线程池包括了一组工作线程，同时还包括了一个用于放置等待执行的任务的队列。
	
	java.util.concurrent.Executors提供了一个 java.util.concurrent.Executor接口的实现
	用于创建线程池。
	
### 显示锁Lock ReentrantLock 和内置锁 synchronized 有什么区别？
	1. synchronized
		内置锁获得锁和释放锁是隐式的，进入synchronized修饰的代码就获得锁，走出相应的代码就释放
		锁。与Synchronized配套使用的通信方法通常有wait(),notify()。
		
		内置锁在进入同步块时，采取的是无限等待的策略，一旦开始等待，就既不能中断也不能取消，容易
		产生饥饿与死锁的问题
		在线程调用notify方法时，会随机选择相应对象的等待队列的一个线程将其唤醒，而不是按照FIFO
		的方式，如果有强烈的公平性要求，比如FIFO就无法满足.
	
	2. ReentrantLock
		ReentrantLock是显示锁，需要显示进行 lock 以及 unlock 操作。
		与ReentrantLock搭配的通行方式是Condition.
		
		private Lock lock = new ReentrantLock();
  		public Condition condition = lock.newCondition();
  		......
  		lock.lock(); //获取同步监视器
  		......
  		condition.await(); / condition.await(long time, TimeUnit unit);
  		......
  		condition.signal(); / condition.signalAll();
  		......
  		lock.unlock(); //释放锁
  		
  		lock.lockInterruptibly() 可以使得线程在等待锁时支持响应中断；lock.tryLock() 可以
  		使得线程在等待一段时间过后如果还未获得锁就停止等待而非一直等待。有了这两种机制就可以更好
  		地制定获得锁的重试机制，而非盲目一直等待，可以更好的避免饥饿和死锁问题
  		
		ReentrantLock可以成为公平锁（非默认的），所谓公平锁就是锁的等待队列的FIFO，不过公平锁
		会带来性能消耗，如果不是必须的不建议使用。
		
	3. 总结
		内置锁最大的优点是简洁易用，显示锁最大的优点是功能丰富。显示锁能够提供定时的锁等待，可中
		断的锁等待、公平性，以及实现非块结构的加锁。优先选择内置锁，内置锁不能满足的情况下使用显
		示锁。
		
### 什么是Executors框架？
	Executor框架是一个根据一组执行策略调用，调度，执行和控制的异步任务的框架。无限制的创建线程
	会引起应用程序内存溢出。所以创建一个线程池是个更好的的解决方案，因为可以限制线程的数量并且可
	以回收再利用这些线程。利用Executors框架可以非常方便的创建一个线程池。
	
### Executor 框架的结构？
	1. 任务
		包括被执行任务需要继承的接口 Runnable 和 Callable 接口
		
	2. 任务的执行
		包括任务执行机制的核心接口 Executor，以及继承自 Executor 接口的 ExecutorService 
		接口。Executor 接口将任务的提交与任务的执行分离。
		
		Executor 框架有两个关键类实现了 ExecutorService 接口， ThreadPoolExecutor 和
		ScheduledThreadPoolExecutor。
		
		ThreadPoolExecutor 是线程池的核心实现类，用来执行被提交的任务。
		ScheduledThreadPoolExecutor是一个实现类，可以在给定的延迟后运行命令，或者定期执行命
		令。ScheduledThreadPoolExecutor 比 Timer 更灵活，功能更强大。
		
		Runnable和Callable接口的实现类，都可以被ThreadPoolExecutor 或 
		ScheduledThreadPoolExecutor 执行。
		
	3. 异步计算的结果
		包括 Future 和实现了 Future 接口的类 FutureTask.
		
### Executor 框架的使用
	1. 主线程首先要创建实现 Runnable接口或者Callable接口的任务对象。工具类Executors可以把一
	个Runnable对象封装为一个Callable对象
	
	2. 然后可以把Runnable对象直接交给ExecutorService执行
	
	3. 最后，主线程可以执行FutureTask.get()方法来等待任务执行完成。主线程也可以执行
	FutureTask.cancel(boolean mayInterruptIfRunning)来取消此任务的执行。
	
### 说一说 ThreadPoolExecutor?
	 Executor框架最核心的类是ThreadPoolExecutor.
	 
	 1. ThreadPoolExecutor的组件构成
		corePool：核心线程池的大小
		maximumPool：最大线程池的大小
		BlockingQueue：用来暂时保存任务的工作队列
		RejectedExecutionHandler：当ThreadPoolExecutor已经关闭或ThreadPoolExecutor已		经饱和时(达到了最大线程池的大小且工作队列已满)，execute()方法将要调用的 Handler.
		
	2. Executor 可以创建3种类型的 ThreadPoolExecutor 线程池
		(1) FixedThreadPool
			创建固定长度的线程池，每次提交任务创建一个线程，直到达到线程池的最大数量，线程池的大
			小不再变化。这个线程池可以创建固定线程数的线程池。特点就是可以重用固定数量的线程池。
			
		(2) CachedThreadPool
			 CachedThreadPool是一个”无限“容量的线程池，它会根据需要创建新线程。特点是可以根据
			 需要来创建新的线程执行任务，没有特定的corePool
			 
		(3) SingleThreadExecutor
			SingleThreadExecutor是使用单个worker线程的Executor。特点是使用单个工作线程执行
			任务。注意：由于在线程池中只有一个工作线程，所以任务可以按照添加顺序执行.
			
		(4) ScheduledThreadPool
			ScheduledThreadPool 创建了一个固定长度的线程池，而且以延迟或者定时的方式来执行任
			务。
			
	3. 饱和策略
		（1）中止策略（默认）：该策略将抛出未检查的 RejectedExecutionException.调用者可以捕
		获这个异常，然后根据需求编写自己的处理代码。
		
		（2）抛弃策略：抛弃该任务
		
		（3）抛弃最旧的策略：抛弃下一个将被执行的任务。
		
		（4）调用者运行策略：实现了一种调节机制，既不会抛弃任务也不会抛出异常，而是将某些任务回
		退给调用者。
		
		
		
### 什么是 Callable 接口 和 Future 接口?
	它和Runnable接口很相似，但它可以返回一个对象或者抛出一个异常。返回类型是一个泛型。
	Callable 任务是并行的，我们必须等待它返回的结果。Future 对象为我们解决了这个问题。在线程
	池提交一个 Callable 任务后返回一个Futrue对象，Future 提供了 get() 方法，get() 方法是
	状态依赖的，它让我们可以知道 Callable 任务的状态以及Callable返回的结果。
。
### 什么是 FutureTask?
	FutureTask 是 Future 的一个基础实现，表示一个异步运算的任务。FutureTask 里面可以传入一
	个 Callable 的具体实现类，可以对这个异步运算的任务的结果进行等待获取、判断是否已经完成、取
	消任务等。通常我们不需要使用FutureTask类，但当我们打算重写Future接口的一些方法并保持原来
	基础的实现是，它就变得非常有用。我们可以仅仅继承于它并重写我们需要的方法。
 	
### 多线程的运行机制，怎么加锁的?

### 线程池怎么实现的，线程池中的coreNum和maxNum有什么不同？

### One loop per thread + threadpool 的理解？ One loop 的 loop 指什么？



# RESTful
### restful api了解不，说说get，put，post，delete的区别？

### post有什么好处，处理json字符串的jar包是什么？




# 项目
## 详细讨论一两个你的项目中的技术细节

# 其他
### 你认为你编程最大的挑战是什么?

# 实习
## 实习主要做了哪些事情？

	
	


