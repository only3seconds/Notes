# 设计模式
	设计模式是人们在面对同类型软件工程设计问题所总结出的一些有用经验。是某类问题的通用设计解决方案。

## 分类

**创建型**

- 单例模式
- 工厂方法模式
- 抽象工厂模式
- 建造者模式
- 原型模式

**结构型**

- 装饰者模式
- 适配器模式
- 代理模式
- 组合模式
- 享元模式
- 桥接模式
- 外观模式

**行为型**

- 观察者模式
- 迭代器模式
- 责任链模式
- 命令模式
- 解释器模式
- 中介者模式
- 备忘录模式
- 状态模式
- 策略模式
- 模板方法模式
- 访问着模式

## 单例模式

	适用场景：
	1. 资源共享的情况下，避免不一致状态。
		例1，应用程序的日志应用，一般都用单例模式实现，因为共享的日志文件一直处于打开状态，只能有一个实例去操作，否则内容不好追加。
		例2， Web应用的配置对象的读取。
	2. 控制资源的情况下，方便资源之间的互相通信。
		例1，多线程的线程池的设计一般也是采用单例模式，这是由于线程池要方便对池中的线程进行控制。
		例2，数据库连接池的设计一般也是采用单例模式，因为数据库连接是一种数据库资源。数据库软件系统中使用数据库连接池，主要是节省打开或者关闭数据库连接所引起的效率损耗	　　
	特点：
	1、单例类只能有一个实例。
	2、单例类必须自己创建自己的唯一实例。
	3、单例类必须给所有其他对象提供这一实例

- 懒汉模式

```java
/**
 * 单例模式之懒汉模式(线程安全：方法同步）
 */
public class Singleton {
    private Singleton() {}
    private static Singleton singleton = null;
    public static synchronized Singleton getInstance() {
        if(singleton == null) {
            singleton = new Singleton();
        }
        return singleton;
    }
}

/**
 * 单例模式之懒汉模式(线程安全: 双重检查锁定）
 */
public class Singleton {
    private Singleton() {
    }

    private static Singleton singleton = null;

    public static Singleton getInstance() {
        if (singleton == null) {
            synchronized (Singleton.class) {
                if (singleton == null) {
                    singleton = new Singleton();
                }
            }
        }
        return singleton;
    }
}

/**
 * 单例模式之懒汉模式(线程安全：静态内部类，推荐，既保证了线程安全，又避免了同步带来的性能问题）
 */
public class Singleton {
    private Singleton() {
    }

    private static class LazyLoader {
        private static Singleton SINGLETON = new Singleton();
    }

    public static final Singleton getInstance() {
        return LazyLoader.SINGLETON;
    }
    
}

```
- 饿汉模式

```java
/**
 * 单例模式之饿汉模式
 */
public class Singleton {
    private Singleton() {
    }

    private static final Singleton singleton = new Singleton();

    public static final Singleton getInstance() {
        return singleton;
    }

}
```

## 工厂模式

### 1. 简单工厂模式

	适用场景：如何能轻松方便地构造对象实例，而不必关心构造对象实例的细节和复杂过程？
	         ---建立一个工厂来创建对象
	

	 
```
 1) 抽象产品角色：它一般是具体产品继承的父类或者实现的接口。         
 2) 具体产品角色：工厂类所创建的对象就是此角色的实例。在java中由一个具体类实现。
 3) 工厂类角色：这是简单工厂模式的核心，用来创建产品
```
### 2. 工厂方法模式


	适用场景：当产品是一个多层次的树状结构时，简单工厂模式中只有一个工厂类来对应这些产品，不能满足要求。

```
 1)抽象产品角色：它是具体产品继承的父类或者是实现的接口。在java中一般有抽象类或者接口来实现。 
 2)具体产品角色：具体工厂角色所创建的对象就是此角色的实例。在java中由具体的类来实现。 
 3)抽象工厂角色： 这是工厂方法模式的核心，它与应用程序无关。是具体工厂角色必须实现的接口或者必须继承的父类。在java中它由抽象类或者接口来实现。 
 4)具体工厂角色：它含有和具体业务逻辑有关的代码。由应用程序调用以创建对应的具体产品的对象。
```   

### 3. 抽象工厂模式

	适用场景：抽象工厂模式是工厂方法模式的升级版本，他用来创建一组相关或者相互依赖的对象。

```
 1)抽象产品族角色: 这是抽象工厂模式的核心，抽象产品的父类，描述抽象产品的公共接口。
 2)抽象产品角色：它是具体产品继承的父类或者是实现的接口。在java中一般有抽象类或者接口来实现。
 抽象产品角色：它是具体产品继承的父类或者是实现的接口。在java中一般有抽象类或者接口来实现。 
 3)具体产品角色：具体工厂角色所创建的对象就是此角色的实例。在java中由具体的类来实现。 
 4)抽象工厂角色： 这是工厂方法模式的核心，它与应用程序无关。是具体工厂角色必须实现的接口或者必须继承的父类。在java中它由抽象类或者接口来实现。 
 5)具体工厂角色：它含有和具体业务逻辑有关的代码。由应用程序调用以创建对应的具体产品的对象。

```

## 装饰者模式

	装饰模式以对客户透明的方式动态地给一个对象附加上更多的责任。换言之，客户端并不会觉得对象在装
	饰前和装饰后有什么不同。装饰模式可以在不使用创造更多子类的情况下，将对象的功能加以扩展。

![](https://img-blog.csdnimg.cn/20190319223544549.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pvdXJuZXlfVHJpcGxlUA==,size_16,color_FFFFFF,t_70)
	
### 1. 角色

```
1) 抽象构件(Component)角色：给出一个抽象接口，以规范准备接收附加责任的对象。
2) 具体构件(ConcreteComponent)角色：定义一个将要接收附加责任的类。
3) 装饰(Decorator)角色：持有一个构件(Component)对象的实例，并定义一个与抽象构件接口一致的接口。
4) 具体装饰(ConcreteDecorator)角色：负责给构件对象“贴上”附加的责任。
```

### 2. 通俗理解

孙悟空72变

![](https://img-blog.csdnimg.cn/201903192322433.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pvdXJuZXlfVHJpcGxlUA==,size_16,color_FFFFFF,t_70)

### 3. 应用

在JAVA I/O库中的应用


### 4. 优点 & 缺点

**优点**

	（1）装饰模式与继承关系的目的都是要扩展对象的功能，但是装饰模式可以提供比继承更多的灵活性。
	    装饰模式允许系统动态决定“贴上”一个需要的“装饰”，或者除掉一个不需要的“装饰”。继承关系则
	    不同，继承关系是静态的，它在系统运行前就决定了
	    
	（2）通过使用不同的具体装饰类以及这些装饰类的排列组合，设计师可以创造出很多不同行为的组合。

**缺点**

	使用装饰模式会产生比使用继承关系更多的对象。更多的对象会使得查错变得困难，特别是这些对象看上
	去都很相像。
	
## 观察者模式

### 1. 角色

```
1) 抽象被观察者角色：一般用一个抽象类和接口来实现。把所有对观察者对象的引用保存在一个集合中，每个被观察者角色都可以有任意数量的观察者。被观察者提供一个接口，可以增加和删除观察者角色。
2) 抽象观察者角色：为所有具体的观察者定义一个接口，在得到主题的通知时更新自己。
3) 具体被观察者角色：在被观察者内部状态改变时，给所有登记过的观察者发出通知。具体被观察者角色通常用一个子类实现。
4) 具体观察者角色：该角色实现抽象观察者角色所要求的更新接口，以便使本身的状态与主题的状态相协调。通常用一个子类实现。如果需要，具体观察者角色可以保存一个指向具体主题角色的引用。
```

### 2. 通俗理解

珠宝商运送钻石，强盗，保镖，警察
### 3. 适用场景

```
1) 当一个抽象模型有两个方面, 其中一个方面依赖于另一方面。将这二者封装在独立的对象中以使它们可以各自独立地改变和复用。
2) 当对一个对象的改变需要同时改变其它对象, 而不知道具体有多少对象有待改变。
3) 当一个对象必须通知其它对象，而它又不能假定其它对象是谁。换言之, 你不希望这些对象是紧密耦合的。

```

## 参考资料

1. [java 23种设计模式 深入理解](https://www.cnblogs.com/foryang/p/5849402.html)
2. [Java设计模式之观察者模式](https://blog.csdn.net/jason0539/article/details/45055233)